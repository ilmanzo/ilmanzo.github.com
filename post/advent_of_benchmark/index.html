<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Benchmarking a Rust function | ilManzo's blog</title>
<meta name=keywords content="programming,Rust,performance,benchmark"><meta name=description content="A first look at Rust performance benchmarking"><meta name=author content="Andrea Manzini"><link rel=canonical href=https://ilmanzo.github.io/post/advent_of_benchmark/><link crossorigin=anonymous href=/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL",{anonymize_ip:!1})}</script><meta property="og:title" content="Benchmarking a Rust function"><meta property="og:description" content="A first look at Rust performance benchmarking"><meta property="og:type" content="article"><meta property="og:url" content="https://ilmanzo.github.io/post/advent_of_benchmark/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-04-02T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Benchmarking a Rust function"><meta name=twitter:description content="A first look at Rust performance benchmarking"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"Benchmarking a Rust function","item":"https://ilmanzo.github.io/post/advent_of_benchmark/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Benchmarking a Rust function","name":"Benchmarking a Rust function","description":"A first look at Rust performance benchmarking","keywords":["programming","Rust","performance","benchmark"],"articleBody":"Once in a while I like to play with Advent Of Code problems ðŸŽ„. Today I decided to tackle an easy one and, since the answer was almost trivial to find, I wanted to go deeper and understand how to measure and improve the performance of the solution.\nSomething About Us In this first problem, they give you a long list of numbers; you need to find the two entries that sum to 2020 and then multiply those two numbers together.\nFor example, if numbers are the following:\n1721 979 366 299 675 1456 The two entries that sum to 2020 are 1721 and 299. Multiplying them together produces 1721 * 299 = 514579.\nOnce solved in a brute-force way, I thought to take the occasion to learn how you can benchmark code in Rust ðŸ¦€.\nGet Lucky First of all, I wrote a quick and dirty solution directly in the main.rs file:\npub fn part1_1(input: \u0026[usize]) -\u003e usize { for i in input { for j in input { if i+j==2020 { return i*j; } } } 0 } fn main() { let input=include_str!(\"../../input.txt\") .lines() .map(|i| i.parse::\u003cusize\u003e().unwrap()) .collect(); println!(\"{}\", part1_1(\u0026input)); } Ughâ€¦ Quadratic complexity! Well, cargo run gives us a correct answer, which wonâ€™t reveal here ðŸ˜‰ So we could call it a day and move to the next problem, or not ?\nTechnologic While it works as expected, that code isnâ€™t easily measurable. So weâ€™d need to take out our function in a separate crate and edit our Cargo.toml accordingly:\n[package] name = \"day01_rust\" version = \"0.1.0\" edition = \"2021\" [lib] name = \"day01\" path = \"src/lib.rs\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] [dev-dependencies] criterion = \"0.4.0\" [[bench]] name = \"benchmark\" harness = false With this setup, we can also factor out the code we want to measure in src/lib.rs:\npub fn part1_1(input: \u0026[usize]) -\u003e usize { for i in input { for j in input { if i+j==2020 { return i*j; } } } 0 } pub fn get_input() -\u003e Vec\u003cusize\u003e { include_str!(\"../../input.txt\") .lines() .map(|i| i.parse::\u003cusize\u003e().unwrap()) .collect() } While our src/main.rs will contain simply importing external functions and invocation:\nuse day01::{get_input, part1}; fn main() { let input=get_input(); println!(\"{}\", part1_1(\u0026input)); } Now we can use the very popular Criterion crate to write our benches/benchmark.rs\nuse criterion::{black_box, criterion_group, criterion_main, Criterion}; use day01::{part1_1, get_input}; pub fn criterion_benchmark(c: \u0026mut Criterion) { let input=get_input(); c.bench_function(\"part1\", |b| b.iter(|| part1_1(black_box(\u0026input)))); } criterion_group!(benches, criterion_benchmark); criterion_main!(benches); The Game Has Changed With this setup, we are able to run cargo benchmark and get cool statistics and measurements of a significant number of executions of our code ðŸ˜Ž.\nRunning benches/benchmark.rs (target/release/deps/benchmark-8bdc3718c6c81796) part1_1 time: [9.5933 Âµs 9.5953 Âµs 9.5974 Âµs] Found 20 outliers among 100 measurements (20.00%) 5 (5.00%) low mild 8 (8.00%) high mild 7 (7.00%) high severe Not bad at all for our first try! Well, Rust is a fast, compiled language and our input is small, less than 200 lines. Can we do better ? Letâ€™s measure a second implementation, will include here only the changed part:\nOne More Time pub fn part1_2(input: \u0026[usize]) -\u003e usize { for n in input { if input.contains(\u0026(2020 - n)) { return n * (2020 - n); } } 0 } Turns out our â€˜smartâ€™ implementation has slightly better performance, as Criterion is able to detect:\nRunning benches/benchmark.rs (target/release/deps/benchmark-8bdc3718c6c81796) part1_2 time: [8.9454 Âµs 8.9482 Âµs 8.9505 Âµs] change: [-6.9929% -6.8888% -6.7959%] (p = 0.00 \u003c 0.05) Performance has improved. Found 14 outliers among 100 measurements (14.00%) 3 (3.00%) low severe 1 (1.00%) low mild 3 (3.00%) high mild 7 (7.00%) high severe Harder, Better, Faster, Stronger With the help of a Set Data Structure we can write a better solution:\npub fn part1_3(input: \u0026[usize]) -\u003e usize { let mut seen = std::collections::HashSet::new(); for n in input { if seen.contains(\u0026(2020-n)) { return n * (2020 - n); } seen.insert(n); } 0 } We simply keep track of the number already passed, and for each number we check if we already seen its complementary. When yes, we are done! How much we gain from this trick ?\npart1_3 time: [6.7853 Âµs 6.7900 Âµs 6.7947 Âµs] change: [-0.2564% -0.1246% +0.0135%] (p = 0.08 \u003e 0.05) Found 5 outliers among 100 measurements (5.00%) 3 (3.00%) low mild 1 (1.00%) high mild 1 (1.00%) high severe Doinâ€™ It Right Our new function is ~30% faster, and the most important thing is that it runs in O(n) time since it iterates over the original data only once. I donâ€™t want to keep this post too long, also because the main purpose of this exercise isnâ€™t abount finding the absolute fastest implementation, but rather to show how to set up a proper benchmark to measure your Rust code.\nAs a little spoiler, Part2 of the daily problem requires us to find 3 numbers which sum up to 2020. Can you think of a solution ? A fast one ? ðŸŽ…\nAround the World Benchmarking is not only about pure CPU performance, but we should consider also memory usage, I/O, caching, thermal efficiency, parallellism and lots of other topics. Some of them are handly collected in the Rust Performance Book, written by Nicholas Nethercote and others, which is a must read, together with the Criterion Documentation. Happy hacking!\n","wordCount":"874","inLanguage":"en","datePublished":"2023-04-02T00:00:00Z","dateModified":"2023-04-02T00:00:00Z","author":{"@type":"Person","name":"Andrea Manzini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/advent_of_benchmark/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Benchmarking a Rust function</h1><div class=post-description>A first look at Rust performance benchmarking</div><div class=post-meta><span title='2023-04-02 00:00:00 +0000 UTC'>April 2, 2023</span>&nbsp;Â·&nbsp;Andrea Manzini</div></header><div class=post-content><p>Once in a while I like to play with <a href=https://adventofcode.com/>Advent Of Code</a> problems &#x1f384;. Today I decided to tackle an <a href=https://adventofcode.com/2020/day/1>easy one</a> and, since the answer was almost trivial to find, I wanted to go deeper and understand how to measure and improve the performance of the solution.</p><h1 id=something-about-us>Something About Us<a hidden class=anchor aria-hidden=true href=#something-about-us>#</a></h1><p>In this first problem, they give you a long list of numbers; you need to find the two entries that sum to <code>2020</code> and then multiply those two numbers together.</p><p>For example, if numbers are the following:</p><pre tabindex=0><code>1721
979
366
299
675
1456
</code></pre><p>The two entries that sum to <code>2020</code> are <code>1721</code> and <code>299</code>. Multiplying them together produces <code>1721 * 299</code> = <code>514579</code>.</p><p>Once solved in a brute-force way, I thought to take the occasion to learn how you can benchmark code in <a href=https://www.rust-lang.org/>Rust</a> &#x1f980;.</p><h1 id=get-lucky>Get Lucky<a hidden class=anchor aria-hidden=true href=#get-lucky>#</a></h1><p>First of all, I wrote a quick and dirty solution directly in the <code>main.rs</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_1</span>(input: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>usize</span>]) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> input {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> input {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i<span style=color:#f92672>+</span>j<span style=color:#f92672>==</span><span style=color:#ae81ff>2020</span> { 
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> i<span style=color:#f92672>*</span>j;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input<span style=color:#f92672>=</span>include_str!(<span style=color:#e6db74>&#34;../../input.txt&#34;</span>)
</span></span><span style=display:flex><span>    .lines()
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> i.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>().unwrap())
</span></span><span style=display:flex><span>    .collect();
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, part1_1(<span style=color:#f92672>&amp;</span>input));
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Ugh&mldr; <strong>Quadratic</strong> complexity! Well, <code>cargo run</code> gives us a correct answer, which won&rsquo;t reveal here &#x1f609; So we could call it a day and move to the next problem, or not ?</p><h1 id=technologic>Technologic<a hidden class=anchor aria-hidden=true href=#technologic>#</a></h1><p>While it works as expected, that code isn&rsquo;t easily measurable. So we&rsquo;d need to take out our function in a separate <code>crate</code> and edit our <code>Cargo.toml</code> accordingly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>package</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;day01_rust&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.1.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>edition</span> = <span style=color:#e6db74>&#34;2021&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>lib</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;day01&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>path</span> = <span style=color:#e6db74>&#34;src/lib.rs&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>dependencies</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>dev-dependencies</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>criterion</span> = <span style=color:#e6db74>&#34;0.4.0&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[[<span style=color:#a6e22e>bench</span>]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;benchmark&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>harness</span> = <span style=color:#66d9ef>false</span></span></span></code></pre></div><p>With this setup, we can also factor out the code we want to measure in <code>src/lib.rs</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_1</span>(input: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>usize</span>]) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> input {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> input {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i<span style=color:#f92672>+</span>j<span style=color:#f92672>==</span><span style=color:#ae81ff>2020</span> { 
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> i<span style=color:#f92672>*</span>j;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_input</span>() -&gt; Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    include_str!(<span style=color:#e6db74>&#34;../../input.txt&#34;</span>)
</span></span><span style=display:flex><span>    .lines()
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> i.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>().unwrap())
</span></span><span style=display:flex><span>    .collect()
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>While our <code>src/main.rs</code> will contain simply importing external functions and invocation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> day01::{get_input, part1};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input<span style=color:#f92672>=</span>get_input();
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, part1_1(<span style=color:#f92672>&amp;</span>input));
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Now we can use the very popular <a href=https://docs.rs/criterion/latest/criterion/>Criterion</a> crate to write our <code>benches/benchmark.rs</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> criterion::{black_box, criterion_group, criterion_main, Criterion};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> day01::{part1_1, get_input};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>criterion_benchmark</span>(c: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Criterion) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input<span style=color:#f92672>=</span>get_input();
</span></span><span style=display:flex><span>    c.bench_function(<span style=color:#e6db74>&#34;part1&#34;</span>, <span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.iter(<span style=color:#f92672>||</span> part1_1(black_box(<span style=color:#f92672>&amp;</span>input))));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>criterion_group!(benches, criterion_benchmark);
</span></span><span style=display:flex><span>criterion_main!(benches);</span></span></code></pre></div><h1 id=the-game-has-changed>The Game Has Changed<a hidden class=anchor aria-hidden=true href=#the-game-has-changed>#</a></h1><p>With this setup, we are able to run <code>cargo benchmark</code> and get cool statistics and measurements of a significant number of executions of our code &#x1f60e;.</p><pre tabindex=0><code>Running benches/benchmark.rs (target/release/deps/benchmark-8bdc3718c6c81796)
part1_1                 time:   [9.5933 Âµs 9.5953 Âµs 9.5974 Âµs]
Found 20 outliers among 100 measurements (20.00%)
  5 (5.00%) low mild
  8 (8.00%) high mild
  7 (7.00%) high severe
</code></pre><p>Not bad at all for our first try! Well, Rust is a fast, compiled language and our input is small, less than 200 lines. Can we do better ? Let&rsquo;s measure a second implementation, will include here only the changed part:</p><h1 id=one-more-time>One More Time<a hidden class=anchor aria-hidden=true href=#one-more-time>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_2</span>(input: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>usize</span>]) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> n <span style=color:#66d9ef>in</span> input {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> input.contains(<span style=color:#f92672>&amp;</span>(<span style=color:#ae81ff>2020</span> <span style=color:#f92672>-</span> n)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> n <span style=color:#f92672>*</span> (<span style=color:#ae81ff>2020</span> <span style=color:#f92672>-</span> n);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Turns out our &lsquo;smart&rsquo; implementation has slightly better performance, as <strong>Criterion</strong> is able to detect:</p><pre tabindex=0><code>Running benches/benchmark.rs (target/release/deps/benchmark-8bdc3718c6c81796)
part1_2                 time:   [8.9454 Âµs 8.9482 Âµs 8.9505 Âµs]
                        change: [-6.9929% -6.8888% -6.7959%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 14 outliers among 100 measurements (14.00%)
  3 (3.00%) low severe
  1 (1.00%) low mild
  3 (3.00%) high mild
  7 (7.00%) high severe
</code></pre><h1 id=harder-better-faster-stronger>Harder, Better, Faster, Stronger<a hidden class=anchor aria-hidden=true href=#harder-better-faster-stronger>#</a></h1><p>With the help of a <a href=https://doc.rust-lang.org/std/collections/struct.HashSet.html>Set Data Structure</a> we can write a better solution:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_3</span>(input: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>usize</span>]) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> seen <span style=color:#f92672>=</span> std::collections::HashSet::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> n <span style=color:#66d9ef>in</span> input {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> seen.contains(<span style=color:#f92672>&amp;</span>(<span style=color:#ae81ff>2020</span><span style=color:#f92672>-</span>n)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> n <span style=color:#f92672>*</span> (<span style=color:#ae81ff>2020</span> <span style=color:#f92672>-</span> n);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        seen.insert(n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We simply keep track of the number already passed, and for each number we check if we already seen its complementary. When yes, we are done!
How much we gain from this trick ?</p><pre tabindex=0><code>part1_3                 time:   [6.7853 Âµs 6.7900 Âµs 6.7947 Âµs]
                        change: [-0.2564% -0.1246% +0.0135%] (p = 0.08 &gt; 0.05)
Found 5 outliers among 100 measurements (5.00%)
  3 (3.00%) low mild
  1 (1.00%) high mild
  1 (1.00%) high severe
</code></pre><h1 id=doin-it-right>Doinâ€™ It Right<a hidden class=anchor aria-hidden=true href=#doin-it-right>#</a></h1><p>Our new function is <code>~30%</code> faster, and the most important thing is that it runs in <em>O(n)</em> time since it iterates over the original data only once.
I don&rsquo;t want to keep this post too long, also because the main purpose of this exercise isn&rsquo;t abount finding the absolute fastest implementation, but rather to show how to set up a proper benchmark to measure your Rust code.</p><p>As a little spoiler, <strong>Part2</strong> of the daily problem requires us to find <code>3</code> numbers which sum up to <code>2020</code>. Can you think of a solution ? A fast one ? &#x1f385;</p><h1 id=around-the-world>Around the World<a hidden class=anchor aria-hidden=true href=#around-the-world>#</a></h1><p>Benchmarking is not only about pure CPU performance, but we should consider also memory usage, I/O, caching, thermal efficiency, parallellism and lots of other topics. Some of them are handly collected in the <a href=https://nnethercote.github.io/perf-book/title-page.html>Rust Performance Book</a>, written by Nicholas Nethercote and others, which is a must read, together with the <a href=https://bheisler.github.io/criterion.rs/book/criterion_rs.html>Criterion Documentation</a>. Happy hacking!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/programming/>programming</a></li><li><a href=https://ilmanzo.github.io/tags/rust/>rust</a></li><li><a href=https://ilmanzo.github.io/tags/performance/>performance</a></li><li><a href=https://ilmanzo.github.io/tags/benchmark/>benchmark</a></li></ul><nav class=paginav><a class=prev href=https://ilmanzo.github.io/post/crystal-demo-effects/><span class=title>Â« Prev</span><br><span>Old-School demo effects with Crystal</span>
</a><a class=next href=https://ilmanzo.github.io/post/inspect-obs-vm-during-build/><span class=title>Next Â»</span><br><span>Debugging a problematic build</span></a></nav></footer></article></main><footer class=footer><span>Â© 2012-2023 Andrea Manzini</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>