<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of code 2025: the diaries | ilManzo's blog</title><meta name=keywords content="hackweek,programming,algorithms,quiz,challenges"><meta name=description content="Having fun with Christmas code challenges"><meta name=author content="Andrea Manzini"><link rel=canonical href=https://ilmanzo.github.io/post/advent_of_code_2025/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ilmanzo.github.io/post/advent_of_code_2025/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL")}</script><meta property="og:url" content="https://ilmanzo.github.io/post/advent_of_code_2025/"><meta property="og:site_name" content="ilManzo's blog"><meta property="og:title" content="Advent of code 2025: the diaries"><meta property="og:description" content="Having fun with Christmas code challenges"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-12-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-01T00:00:00+00:00"><meta property="article:tag" content="Hackweek"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="Quiz"><meta property="article:tag" content="Challenges"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of code 2025: the diaries"><meta name=twitter:description content="Having fun with Christmas code challenges"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"Advent of code 2025: the diaries","item":"https://ilmanzo.github.io/post/advent_of_code_2025/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of code 2025: the diaries","name":"Advent of code 2025: the diaries","description":"Having fun with Christmas code challenges","keywords":["hackweek","programming","algorithms","quiz","challenges"],"articleBody":"üéÑ Intro It is December, the most wonderful time of the year for programmers. But as we log in for Advent of Code (AoC) 2025, you might notice the atmosphere is a little different. We passed a decade of Eric Wastl‚Äôs incredible work, and with this milestone comes a significant shift in tradition.\nBefore diving into solutions, I want to take a moment to reflect on the state of AoC this year, the changes we are seeing, and why‚Äîdespite everything‚Äîwe keep coming back to the terminal.\nThe 2025 Format Changes If you are looking for the Global Leaderboard or preparing for a 25-day marathon, you have likely noticed two major adjustments:\nNo Global Leaderboard: The competitive rush has been removed this year. A 12-Day Calendar: Instead of the usual 25 days, the event runs for 12 days. While these changes might feel surprising to veterans, they come with a message of empathy. Maintaining a project of this magnitude for ten years is a grueling, massive commitment. Eric has consistently operated on a whole other level to bring us these elegant, funny, and creative challenges. Acknowledging the ‚Äúhuman cost‚Äù of this event means supporting the creator‚Äôs need to protect his time and mental health.\nWhy We Still Solve In 2025, amid the noise of AI and code assistants, a valid question arises: ‚ÄúWhy bother solving puzzles when an AI can do it in seconds?‚Äù\nThe answer is simple: People still go to musicals and live concerts even though Spotify exists.\nWe don‚Äôt do Advent of Code because it is the ‚Äúefficient‚Äù way to get an answer. We do it because we want to solve the puzzle. We do it for the thrill, the frustration, and the learning. AoC is a way to reconnect with the simple love of programming. It caters to every level, from the beginner just starting out to the seasoned dev looking for a spark.\nA Generational Tradition Whether it is 25 days or 12 days, Advent of Code has become a tradition as strong as Star Wars for many of us. It is something to pass down; there are children today wearing AoC pajamas, growing up with these puzzles as a holiday staple.\nSo, to Eric: Thank you for the last 10 years. We are here for the puzzles, the community, and the tradition‚Äîin whatever format works for you.\nNow, let‚Äôs open up the editor and solve Day 1. SPOILER ALERT!\n‚è∞ Day 1 : The Safe Oh no, apparently Elves have discovered Project Management! (I suspect this to be an hint about the reduced number of stars this year, did Eric switch role?)\nYou have a safe with 100-positions dial (0 to 99), and istructions to rotate Left and Right a number of time : L68 L30 R48 L5 R60 L55 L1 L99 R14 L82 and so on. Initial dial position is 50. In the first part, you need to count how many times the dial STOPS exactly at number 0; on the second part (revealed after 1st solution) you need to count how many times it PASSED by the 0 number.\n(animation courtesy of https://www.reddit.com/user/Disastrous-Funny-781/)\nHere an elegant solution in AWK:\nBEGIN { p = 50 } { c = substr($0, 2) p = (p + (substr($0, 1, 1) == \"R\" ? c : 100 - c)) % 100 n += !p } END { print n } This takes advantage of modular arithmetic: rotating Left by N is equivalent to rotate Right by 100-N.\nüéÅ Day 2 : Gift Shop Some young elves played with the gift shop computer and messed up the product ids!\nYou are given a list of ranges, like 11-22,95-115,998-1012,1188511880-1188511890,222220-222224, 1698522-1698528,446443-446449,38593856-38593862,565653-565659, 824824821-824824827,2121212118-2121212124 and you must find out the one that are not valid ids.\nFor part1 , the invalid ids are the ones that repeats exactly twice, like 11 or 123123. For part2, they can repeat twice or more, like 131313\n(animation courtesy of https://www.reddit.com/user/Boojum/)\nGiven the problem is all about filtering a list, I reached for some functional style . The D Programming Language has nice features:\nbool isInvalidId1(string id) { auto mid = id.length / 2; return id.length \u003e 0 \u0026\u0026 id.length % 2 == 0 \u0026\u0026 id[0 .. mid] == id[mid .. $]; } bool isInvalidId2(string id) { auto m = id.length; foreach (k; 2 .. m + 1) { if (m % k == 0) { auto firstToken = id[0 .. m / k]; if (firstToken.replicate(k).equal(id)) return true; } } return false; } void main() { auto ranges = stdin.readln().strip.split(',').map!(pair =\u003e pair.split('-').map!(to!long)); auto numbers = ranges.map!(r =\u003e iota(r[0], r[1] + 1).map!(to!string)).joiner; writeln(numbers.filter!isInvalidId1.map!(to!long).sum); writeln(numbers.filter!isInvalidId2.map!(to!long).sum); } BTW this problem is interesting because it can be tackled in many ways: string comparison, regular expressions, and purely arithmetic. We can also notice that our input range is limited, e.g. the biggest numbers are ten digits. This means that the possible ways to ‚Äúrepeat‚Äù any digit pattern are limited as well.\nüîã Day 3 : Battery Joltage You need to reach the lower floors, but unfortunately the elevators are out of power. Today‚Äôs problem is about connecting together some batteries to get the most ‚ÄúJoltage‚Äù out of them. So you have four battery packs, represented here by the following lines:\n987654321111111 811111111111119 234234234234278 818181911112111 for each pack, you want to find the greatest number you can get by connecting two batteries, for example on the first row, the 9 and the 8 gives 98.\n(animation courtesy of https://www.reddit.com/user/danmaps/)\nOn the second part you‚Äôll need to connect 12 batteries.\nToday‚Äôs solution in Nim (I‚Äôll publish here just part1, you can find part2 on my repo)\ntemplate benchmark(code: untyped) = block: let t0 = getMonoTime() code let elapsed = getMonoTime() - t0 echo \"Time \", elapsed.inMilliseconds(), \" ms\" proc part1(data: seq[int]): int = for i in 0 ..\u003c data.len - 1: let currentVal = 10 * data[i] + data[i + 1 .. ^1].max result = max(result, currentVal) var input: seq[seq[int]] for line in stdin.lines: input.add line.map(proc(c: char): int = parseInt($c)) benchmark: echo \"Part 1: \", input.map(part1).sum The algorithm is straightforward: for each digit, pair it with the biggest subsequent one. The pair is a candidate to become the new maximum.\nA couple of observations about the Nim language, which in my opinion has a lot of potential:\nI like how you can easily write templates (see the benchmark at the top) and how they seamlessly integrate with the language syntax the special result variable is handy for any calculation and automatically returned at the end of the function the program compile to very fast native binary: using the real 100x200 input, the program outputs the correct value in ~2 milliseconds. üßª Day 4 : Rolls of Paper Proceeding towards the underground base, we find the Elves printing department, where they print the famous ‚Äúgood and bad‚Äù list. The forklifts are very busy with giant rolls of paper @ so you decide to give an hand.\n..@@.@@@@. @@@.@.@.@@ @@@@@.@.@@ @.@@@@..@. @@.@@@@.@@ .@@@@@@@.@ .@.@.@.@@@ @.@@@.@@@@ .@@@@@@@@. @.@.@@@.@. Turns out we can move only the rolls that have less than 4 adjacent items!\n(animation courtesy of https://www.reddit.com/user/wimglenn/)\nI want to try out Zig for this exercise, so I fear the code will be too long to be included here. If you‚Äôre interested, check the repository!\nü•ê Day 5 : The Cafeteria After breaking the wall (!) with a forklift, you discover there is a cafeteria behind. Today‚Äôs task is to find fresh ingredients id among the spoiled ones, given a list of ranges and the id to check:\n3-5 10-14 16-20 12-18 1 5 8 11 17 32 Upper half of the input is the fresh ranges, lower one contains the ingredients. For example 1 is spoiled because is not contained in any range, while 11 belongs to 10-14 so it‚Äôs fresh.\nThis problem is very nice because it can be solved in many different ways, exploring efficiency concepts and set theory algorithms. I adopted a functional approach, using Elixir as a language. Complete code is on the repository\nOn first part, we just count how many ingredients falls into our ‚Äúfresh ranges‚Äù.\ndef part1(fresh, ingredients) do Enum.count(ingredients, fn ingredient -\u003e Enum.any?(fresh, \u0026(ingredient in \u00261)) end) end To solve second part, we basically need to ‚Äújoin‚Äù all the ranges and count all the IDs that falls inside the range. This is a job for the pipe operator!\ndef part2(fresh) do fresh |\u003e Enum.sort() |\u003e merge_ranges() |\u003e Enum.map(\u0026Range.size/1) |\u003e Enum.sum() end (animation courtesy of https://www.reddit.com/user/Ok-Curve902/)\nThe core logic is performed by the merge_ranges() function. Let‚Äôs see it:\ndefp merge_ranges([]), do: [] defp merge_ranges([r1, r2 | rest]) when r2.first \u003c= r1.last + 1 do merged_range = r1.first..max(r1.last, r2.last) merge_ranges([merged_range | rest]) end defp merge_ranges([head | tail]) do [head | merge_ranges(tail)] end It‚Äôs a recursive function, that takes advantage of Elixir pattern matching.\nthe base case, an empty list, just return the empty list the merge case: when the ranges overlaps, it creates a merged_range. This new range starts at the beginning of the first range (r1.first) and ends at the greater of the two ending points (max(r1.last, r2.last)). It then calls merge_ranges again. Crucially, it passes a new list where r1 and r2 have been replaced by the single merged_range. This allows the newly formed range to be checked for overlaps against the next range in the list (rest). the ‚Äúno merge‚Äù case: since head doesn‚Äôt overlap with the next range, it‚Äôs considered a final, complete range for now. We can place it at the front of our result list. The function then calls merge_ranges on the tail of the list to continue the process for all subsequent ranges. The result of that recursive call is appended to head. By combining these three clauses, the function elegantly walks through the sorted list, merging ranges as it goes, until the entire list has been processed.\n(animation courtesy of https://www.reddit.com/user/Just-Routine-5505/)\nüéÖ Notes and references I will collect here all the links and references or related things to AoC25\n(warning: there might be commercial offers)\nAdvent of DevOps: https://sadservers.com/advent Advent of Cyber: https://tryhackme.com/adventofcyber25 AoC in Kotlin: https://blog.jetbrains.com/kotlin/2025/11/advent-of-code-in-kotlin-2025/ AoC Subreddit: https://www.reddit.com/r/adventofcode/ An old time classic‚Ä¶ The Perl Advent Calendar Day 6 visualization by https://www.reddit.com/user/Ok-Curve902/ Day 7 solved on a real Christmas Tree! courtesy of https://www.reddit.com/user/EverybodyCodes/\n","wordCount":"1703","inLanguage":"en","datePublished":"2025-12-01T00:00:00Z","dateModified":"2025-12-01T00:00:00Z","author":{"@type":"Person","name":"Andrea Manzini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/advent_of_code_2025/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Advent of code 2025: the diaries</h1><div class=post-description>Having fun with Christmas code challenges</div><div class=post-meta><span title='2025-12-01 00:00:00 +0000 UTC'>December 1, 2025</span>&nbsp;¬∑&nbsp;<span>Andrea Manzini</span></div></header><div class=post-content><h2 id=-intro>üéÑ Intro<a hidden class=anchor aria-hidden=true href=#-intro>#</a></h2><p>It is December, the most wonderful time of the year for programmers. But as we log in for <a href=https://adventofcode.com/2025>Advent of Code (AoC) 2025</a>, you might notice the atmosphere is a little different. We passed a decade of Eric Wastl‚Äôs incredible work, and with this milestone comes a significant shift in tradition.</p><p>Before diving into solutions, I want to take a moment to reflect on the state of AoC this year, the changes we are seeing, and why‚Äîdespite everything‚Äîwe keep coming back to the terminal.</p><h3 id=the-2025-format-changes>The 2025 Format Changes<a hidden class=anchor aria-hidden=true href=#the-2025-format-changes>#</a></h3><p>If you are looking for the Global Leaderboard or preparing for a 25-day marathon, you have likely noticed two major adjustments:</p><ul><li>No Global Leaderboard: The competitive rush has been removed this year.</li><li>A 12-Day Calendar: Instead of the usual 25 days, the event runs for 12 days.</li></ul><p>While these changes might feel surprising to veterans, they come with a message of empathy. Maintaining a project of this magnitude for ten years is a grueling, massive commitment. Eric has consistently operated on a whole other level to bring us these elegant, funny, and creative challenges. Acknowledging the &ldquo;human cost&rdquo; of this event means supporting the creator‚Äôs need to protect his time and mental health.</p><h3 id=why-we-still-solve>Why We Still Solve<a hidden class=anchor aria-hidden=true href=#why-we-still-solve>#</a></h3><p>In 2025, amid the noise of AI and code assistants, a valid question arises: <em>&ldquo;Why bother solving puzzles when an AI can do it in seconds?&rdquo;</em></p><p>The answer is simple: People still go to musicals and live concerts even though Spotify exists.</p><p>We don‚Äôt do Advent of Code because it is the &ldquo;efficient&rdquo; way to get an answer. We do it because <em>we want to solve the puzzle</em>. We do it for the thrill, the frustration, and the learning. AoC is a way to reconnect with the simple love of programming. It caters to every level, from the beginner just starting out to the seasoned dev looking for a spark.</p><h3 id=a-generational-tradition>A Generational Tradition<a hidden class=anchor aria-hidden=true href=#a-generational-tradition>#</a></h3><p>Whether it is 25 days or 12 days, Advent of Code has become a tradition as strong as Star Wars for many of us. It is something to pass down; there are children today wearing AoC pajamas, growing up with these puzzles as a holiday staple.</p><p>So, to <a href=https://was.tl/>Eric</a>: Thank you for the last 10 years. We are here for the puzzles, the community, and the tradition‚Äîin whatever format works for you.</p><p>Now, let&rsquo;s open up the editor and solve Day 1. SPOILER ALERT!</p><h2 id=-day-1--the-safe>‚è∞ <a href=https://adventofcode.com/2025/day/1>Day 1</a> : The Safe<a hidden class=anchor aria-hidden=true href=#-day-1--the-safe>#</a></h2><p>Oh no, apparently Elves have discovered Project Management! (I suspect this to be an hint about the reduced number of stars this year, did <a href=https://was.tl/>Eric</a> switch role?)</p><p>You have a safe with 100-positions dial (0 to 99), and istructions to rotate Left and Right a number of time : <code>L68 L30 R48 L5 R60 L55 L1 L99 R14 L82</code> and so on. Initial dial position is 50. In the first part, you need to count how many times the dial STOPS exactly at number 0; on the second part (revealed after 1st solution) you need to count how many times it PASSED by the 0 number.</p><p><img alt=day01 loading=lazy src=/img/aoc2025/day01.gif>
(animation courtesy of <a href=https://www.reddit.com/user/Disastrous-Funny-781/>https://www.reddit.com/user/Disastrous-Funny-781/</a>)</p><p>Here an elegant solution in AWK:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-awk data-lang=awk><span style=display:flex><span>BEGIN { <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>50</span> }
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>substr</span>(<span style=color:#f92672>$</span><span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> (<span style=color:#66d9ef>substr</span>(<span style=color:#f92672>$</span><span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;R&#34;</span> <span style=color:#960050;background-color:#1e0010>?</span> <span style=color:#a6e22e>c</span> <span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>c</span>)) <span style=color:#f92672>%</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>+=</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>p</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>END { <span style=color:#66d9ef>print</span> <span style=color:#a6e22e>n</span> }
</span></span></code></pre></div><p>This takes advantage of modular arithmetic: rotating Left by N is equivalent to rotate Right by 100-N.</p><h2 id=-day-2--gift-shop>üéÅ <a href=https://adventofcode.com/2025/day/2>Day 2</a> : Gift Shop<a hidden class=anchor aria-hidden=true href=#-day-2--gift-shop>#</a></h2><p>Some young elves played with the gift shop computer and messed up the product ids!</p><p>You are given a list of ranges, like <code>11-22,95-115,998-1012,1188511880-1188511890,222220-222224, 1698522-1698528,446443-446449,38593856-38593862,565653-565659, 824824821-824824827,2121212118-2121212124</code> and you must find out the one that are not valid ids.</p><p>For part1 , the invalid ids are the ones that repeats exactly twice, like <code>11</code> or <code>123123</code>. For part2, they can repeat twice or more, like <code>131313</code></p><p><img alt=day02 loading=lazy src=/img/aoc2025/day02.gif>
(animation courtesy of <a href=https://www.reddit.com/user/Boojum/>https://www.reddit.com/user/Boojum/</a>)</p><p>Given the problem is all about filtering a list, I reached for some <em>functional style</em> . The <a href=https://dlang.org/>D Programming Language</a> has nice features:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-D data-lang=D><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isInvalidId1</span><span style=color:#f92672>(</span>string id<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> mid <span style=color:#f92672>=</span> id<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> id<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> id<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> id<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>..</span> mid<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> id<span style=color:#f92672>[</span>mid <span style=color:#f92672>..</span> $<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isInvalidId2</span><span style=color:#f92672>(</span>string id<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> m <span style=color:#f92672>=</span> id<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>foreach</span> <span style=color:#f92672>(</span>k<span style=color:#f92672>;</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>..</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>m <span style=color:#f92672>%</span> k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> firstToken <span style=color:#f92672>=</span> id<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>..</span> m <span style=color:#f92672>/</span> k<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>firstToken<span style=color:#f92672>.</span><span style=color:#a6e22e>replicate</span><span style=color:#f92672>(</span>k<span style=color:#f92672>).</span><span style=color:#a6e22e>equal</span><span style=color:#f92672>(</span>id<span style=color:#f92672>))</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> ranges <span style=color:#f92672>=</span> stdin<span style=color:#f92672>.</span><span style=color:#a6e22e>readln</span><span style=color:#f92672>().</span><span style=color:#a6e22e>strip</span><span style=color:#f92672>.</span><span style=color:#a6e22e>split</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#39;,&#39;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>map</span><span style=color:#f92672>!(</span>pair <span style=color:#f92672>=&gt;</span> pair<span style=color:#f92672>.</span><span style=color:#a6e22e>split</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#39;-&#39;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>map</span><span style=color:#f92672>!(</span>to<span style=color:#f92672>!</span><span style=color:#66d9ef>long</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> numbers <span style=color:#f92672>=</span> ranges<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>!(</span>r <span style=color:#f92672>=&gt;</span> iota<span style=color:#f92672>(</span>r<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>],</span> r<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>).</span><span style=color:#a6e22e>map</span><span style=color:#f92672>!(</span>to<span style=color:#f92672>!</span>string<span style=color:#f92672>)).</span><span style=color:#a6e22e>joiner</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    writeln<span style=color:#f92672>(</span>numbers<span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>!</span>isInvalidId1<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>!(</span>to<span style=color:#f92672>!</span><span style=color:#66d9ef>long</span><span style=color:#f92672>).</span><span style=color:#a6e22e>sum</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    writeln<span style=color:#f92672>(</span>numbers<span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>!</span>isInvalidId2<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>!(</span>to<span style=color:#f92672>!</span><span style=color:#66d9ef>long</span><span style=color:#f92672>).</span><span style=color:#a6e22e>sum</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>BTW this problem is interesting because it can be tackled in many ways: string comparison, regular expressions, and purely arithmetic.
We can also notice that our input range is limited, e.g. the biggest numbers are ten digits. This means that the possible ways to &ldquo;repeat&rdquo; any digit pattern are limited as well.</p><h2 id=-day-3--battery-joltage>üîã <a href=https://adventofcode.com/2025/day/3>Day 3</a> : Battery Joltage<a hidden class=anchor aria-hidden=true href=#-day-3--battery-joltage>#</a></h2><p>You need to reach the lower floors, but unfortunately the elevators are out of power. Today&rsquo;s problem is about connecting together some batteries to get the most &ldquo;Joltage&rdquo; out of them.
So you have four battery packs, represented here by the following lines:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>987654321111111
</span></span><span style=display:flex><span>811111111111119
</span></span><span style=display:flex><span>234234234234278
</span></span><span style=display:flex><span>818181911112111
</span></span></code></pre></div><p>for each pack, you want to find the greatest number you can get by connecting two batteries, for example on the first row, the <code>9</code> and the <code>8</code> gives <code>98</code>.</p><p><img alt=day01 loading=lazy src=/img/aoc2025/day03.gif>
(animation courtesy of <a href=https://www.reddit.com/user/danmaps/>https://www.reddit.com/user/danmaps/</a>)</p><p>On the second part you&rsquo;ll need to connect 12 batteries.</p><p>Today&rsquo;s solution in Nim (I&rsquo;ll publish here just part1, you can find <a href=https://github.com/ilmanzo/advent_of_code/tree/master/2025/day03>part2 on my repo</a>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> benchmark(code: untyped) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>block</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> t0 <span style=color:#f92672>=</span> getMonoTime()
</span></span><span style=display:flex><span>    code
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> elapsed <span style=color:#f92672>=</span> getMonoTime() <span style=color:#f92672>-</span> t0
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Time &#34;</span>, elapsed.inMilliseconds(), <span style=color:#e6db74>&#34; ms&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>part1</span>(data: <span style=color:#66d9ef>seq</span><span style=color:#f92672>[</span><span style=color:#66d9ef>int</span><span style=color:#f92672>]</span>): <span style=color:#66d9ef>int</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> <span style=color:#ae81ff>0</span> ..<span style=color:#f92672>&lt;</span> data.len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> currentVal <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> data<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> data<span style=color:#f92672>[</span>i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> .. ^<span style=color:#ae81ff>1</span><span style=color:#f92672>]</span>.max
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> max(result, currentVal)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> input: <span style=color:#66d9ef>seq</span><span style=color:#f92672>[</span><span style=color:#66d9ef>seq</span><span style=color:#f92672>[</span><span style=color:#66d9ef>int</span><span style=color:#f92672>]]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> stdin.lines:
</span></span><span style=display:flex><span>  input.add line.map(<span style=color:#66d9ef>proc</span>(c: <span style=color:#66d9ef>char</span>): <span style=color:#66d9ef>int</span> <span style=color:#f92672>=</span> parseInt(<span style=color:#f92672>$</span>c))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>benchmark:
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Part 1: &#34;</span>, input.map(part1).sum</span></span></code></pre></div><p>The algorithm is straightforward: for each digit, pair it with the biggest subsequent one. The pair is a candidate to become the new maximum.</p><p>A couple of observations about the Nim language, which in my opinion has a lot of potential:</p><ul><li>I like how you can easily write templates (see the benchmark at the top) and how they seamlessly integrate with the language syntax</li><li>the special <code>result</code> variable is handy for any calculation and automatically returned at the end of the function</li><li>the program compile to very fast native binary: using the real 100x200 input, the program outputs the correct value in ~2 milliseconds.</li></ul><h2 id=-day-4--rolls-of-paper>üßª <a href=https://adventofcode.com/2025/day/4>Day 4</a> : Rolls of Paper<a hidden class=anchor aria-hidden=true href=#-day-4--rolls-of-paper>#</a></h2><p>Proceeding towards the underground base, we find the Elves printing department, where they print the famous &ldquo;good and bad&rdquo; list.
The forklifts are very busy with giant rolls of paper <code>@</code> so you decide to give an hand.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>..@@.@@@@.
</span></span><span style=display:flex><span>@@@.@.@.@@
</span></span><span style=display:flex><span>@@@@@.@.@@
</span></span><span style=display:flex><span>@.@@@@..@.
</span></span><span style=display:flex><span>@@.@@@@.@@
</span></span><span style=display:flex><span>.@@@@@@@.@
</span></span><span style=display:flex><span>.@.@.@.@@@
</span></span><span style=display:flex><span>@.@@@.@@@@
</span></span><span style=display:flex><span>.@@@@@@@@.
</span></span><span style=display:flex><span>@.@.@@@.@.
</span></span></code></pre></div><p>Turns out we can move only the rolls that have less than 4 adjacent items!</p><p><img alt=day04 loading=lazy src=/img/aoc2025/day04.gif>
(animation courtesy of <a href=https://www.reddit.com/user/wimglenn/>https://www.reddit.com/user/wimglenn/</a>)</p><p>I want to try out <a href=https://ziglang.org/>Zig</a> for this exercise, so I fear the code will be too long to be included here. If you&rsquo;re interested, check the <a href=https://github.com/ilmanzo/advent_of_code/tree/master/2025/day04>repository</a>!</p><h2 id=-day-5--the-cafeteria>ü•ê <a href=https://adventofcode.com/2025/day/5>Day 5</a> : The Cafeteria<a hidden class=anchor aria-hidden=true href=#-day-5--the-cafeteria>#</a></h2><p>After breaking the wall (!) with a forklift, you discover there is a cafeteria behind. Today&rsquo;s task is to find <em>fresh</em> ingredients id among the spoiled ones, given a list of ranges and the id to check:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>3-5
</span></span><span style=display:flex><span>10-14
</span></span><span style=display:flex><span>16-20
</span></span><span style=display:flex><span>12-18
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>5
</span></span><span style=display:flex><span>8
</span></span><span style=display:flex><span>11
</span></span><span style=display:flex><span>17
</span></span><span style=display:flex><span>32
</span></span></code></pre></div><p>Upper half of the input is the fresh ranges, lower one contains the ingredients. For example <code>1</code> is spoiled because is not contained in any range, while <code>11</code> belongs to <code>10-14</code> so it&rsquo;s fresh.</p><p>This problem is very nice because it can be solved in many different ways, exploring efficiency concepts and set theory algorithms.
I adopted a functional approach, using Elixir as a language. Complete code is on the <a href=https://github.com/ilmanzo/advent_of_code/tree/master/2025/day05>repository</a></p><p>On first part, we just count how many ingredients falls into our &ldquo;fresh ranges&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> part1(fresh, ingredients) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Enum</span><span style=color:#f92672>.</span>count(ingredients, <span style=color:#66d9ef>fn</span> ingredient <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Enum</span><span style=color:#f92672>.</span>any?(fresh, <span style=color:#f92672>&amp;</span>(ingredient <span style=color:#f92672>in</span> &amp;1))
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span></span></span></code></pre></div><p>To solve second part, we basically need to &ldquo;join&rdquo; all the ranges and count all the IDs that falls inside the range. This is a job for the <a href=https://elixirschool.com/en/lessons/basics/pipe_operator>pipe operator</a>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> part2(fresh) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      fresh
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> <span style=color:#a6e22e>Enum</span><span style=color:#f92672>.</span>sort()
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> merge_ranges()
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> <span style=color:#a6e22e>Enum</span><span style=color:#f92672>.</span>map(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Range</span><span style=color:#f92672>.</span>size<span style=color:#f92672>/</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>      <span style=color:#f92672>|&gt;</span> <span style=color:#a6e22e>Enum</span><span style=color:#f92672>.</span>sum()
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span></span></span></code></pre></div><p><img alt=day05a loading=lazy src=/img/aoc2025/day05a.gif>
(animation courtesy of <a href=https://www.reddit.com/user/Ok-Curve902/>https://www.reddit.com/user/Ok-Curve902/</a>)</p><p>The core logic is performed by the <code>merge_ranges()</code> function. Let&rsquo;s see it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>defp</span> merge_ranges([]), <span style=color:#e6db74>do</span>: []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>defp</span> merge_ranges([r1, r2 <span style=color:#f92672>|</span> rest]) <span style=color:#f92672>when</span> r2<span style=color:#f92672>.</span>first <span style=color:#f92672>&lt;=</span> r1<span style=color:#f92672>.</span>last <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  merged_range <span style=color:#f92672>=</span> r1<span style=color:#f92672>.</span>first<span style=color:#f92672>..</span>max(r1<span style=color:#f92672>.</span>last, r2<span style=color:#f92672>.</span>last)
</span></span><span style=display:flex><span>  merge_ranges([merged_range <span style=color:#f92672>|</span> rest])
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>defp</span> merge_ranges([head <span style=color:#f92672>|</span> tail]) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  [head <span style=color:#f92672>|</span> merge_ranges(tail)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span></span></span></code></pre></div><p>It&rsquo;s a recursive function, that takes advantage of Elixir pattern matching.</p><ul><li>the base case, an empty list, just return the empty list</li><li>the merge case: when the ranges overlaps, it creates a <code>merged_range</code>. This new range starts at the beginning of the first range <code>(r1.first)</code> and ends at the greater of the two ending points <code>(max(r1.last, r2.last))</code>. It then calls <code>merge_ranges</code> again. Crucially, it passes a new list where <code>r1</code> and <code>r2</code> have been replaced by the single merged_range. This allows the newly formed range to be checked for overlaps against the next range in the list <code>(rest)</code>.</li><li>the &ldquo;no merge&rdquo; case: since <code>head</code> doesn&rsquo;t overlap with the next range, it&rsquo;s considered a final, complete range for now. We can place it at the front of our result list. The function then calls <code>merge_ranges</code> on the <code>tail</code> of the list to continue the process for all subsequent ranges. The result of that recursive call is appended to head.</li></ul><p>By combining these three clauses, the function elegantly walks through the sorted list, merging ranges as it goes, until the entire list has been processed.</p><p><img alt=day05b loading=lazy src=/img/aoc2025/day05b.gif>
(animation courtesy of <a href=https://www.reddit.com/user/Just-Routine-5505/>https://www.reddit.com/user/Just-Routine-5505/</a>)</p><h2 id=-notes-and-references>üéÖ Notes and references<a hidden class=anchor aria-hidden=true href=#-notes-and-references>#</a></h2><p>I will collect here all the links and references or related things to AoC25</p><p>(warning: there might be commercial offers)</p><ul><li>Advent of DevOps: <a href=https://sadservers.com/advent>https://sadservers.com/advent</a></li><li>Advent of Cyber: <a href=https://tryhackme.com/adventofcyber25>https://tryhackme.com/adventofcyber25</a></li><li>AoC in Kotlin: <a href=https://blog.jetbrains.com/kotlin/2025/11/advent-of-code-in-kotlin-2025/>https://blog.jetbrains.com/kotlin/2025/11/advent-of-code-in-kotlin-2025/</a></li><li>AoC Subreddit: <a href=https://www.reddit.com/r/adventofcode/>https://www.reddit.com/r/adventofcode/</a></li><li>An old time classic&mldr; <a href=https://perladvent.org/2025/2025-12-01.html>The Perl Advent Calendar</a></li></ul><p><a href=https://adventofcode.com/2025/day/6>Day 6</a> visualization by <a href=https://www.reddit.com/user/Ok-Curve902/>https://www.reddit.com/user/Ok-Curve902/</a>
<img alt=day06 loading=lazy src=/img/aoc2025/day06.gif></p><p><a href=https://adventofcode.com/2025/day/7>Day 7</a> solved on a real Christmas Tree!
<img alt=tree loading=lazy src=https://i.ibb.co/dyCTz70/ezgif-39c8284705882154-1.gif>
courtesy of <a href=https://www.reddit.com/user/EverybodyCodes/>https://www.reddit.com/user/EverybodyCodes/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/hackweek/>Hackweek</a></li><li><a href=https://ilmanzo.github.io/tags/programming/>Programming</a></li><li><a href=https://ilmanzo.github.io/tags/algorithms/>Algorithms</a></li><li><a href=https://ilmanzo.github.io/tags/quiz/>Quiz</a></li><li><a href=https://ilmanzo.github.io/tags/challenges/>Challenges</a></li></ul><nav class=paginav><a class=prev href=https://ilmanzo.github.io/post/automating_job_cloning/><span class=title>¬´ Prev</span><br><span>Automating OpenQA Job Cloning with Python and YAML</span>
</a><a class=next href=https://ilmanzo.github.io/post/october_2025_conferences/><span class=title>Next ¬ª</span><br><span>October 2025 conferences recap</span></a></nav></footer></article></main><footer class=footer><span>¬© 2012-2025 Andrea Manzini</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>