<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Automating OpenQA Job Cloning with Python and YAML | ilManzo's blog</title><meta name=keywords content="openQA,automation,python,devops,testing,scripting"><meta name=description content="üéâ Happy New Year!
As anyone working with OpenQA knows, it is a powerful tool for automated testing. But sometimes, the workflow around re-triggering those tests for investigation purposes can feel a bit&mldr; Manual.
Recently, I found myself in a repetitive cycle while debugging complex test scenarios. My workflow looked something like this:

Take a known &ldquo;good&rdquo; job URL.
Open a scratchpad editor.
Craft a long openqa-clone-job command with tons of specific override parameters (BUILD=0, custom git branches, skipping specific modules, etc.).
Run the command in the terminal, wait for the output.
Painfully visual scan of the terminal output, to identify the newly created job URLs, and select them with my mouse, to copy them.
Paste them into openqa-mon or a text file to track their progress.

Till now I used a Bash script that kind of helped, but modifying giant arrays of arguments for every different debugging scenario was annoying and error-prone."><meta name=author content><link rel=canonical href=https://ilmanzo.github.io/post/automating_job_cloning/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ilmanzo.github.io/post/automating_job_cloning/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL")}</script><meta property="og:url" content="https://ilmanzo.github.io/post/automating_job_cloning/"><meta property="og:site_name" content="ilManzo's blog"><meta property="og:title" content="Automating OpenQA Job Cloning with Python and YAML"><meta property="og:description" content="üéâ Happy New Year! As anyone working with OpenQA knows, it is a powerful tool for automated testing. But sometimes, the workflow around re-triggering those tests for investigation purposes can feel a bit‚Ä¶ Manual.
Recently, I found myself in a repetitive cycle while debugging complex test scenarios. My workflow looked something like this:
Take a known ‚Äúgood‚Äù job URL. Open a scratchpad editor. Craft a long openqa-clone-job command with tons of specific override parameters (BUILD=0, custom git branches, skipping specific modules, etc.). Run the command in the terminal, wait for the output. Painfully visual scan of the terminal output, to identify the newly created job URLs, and select them with my mouse, to copy them. Paste them into openqa-mon or a text file to track their progress. Till now I used a Bash script that kind of helped, but modifying giant arrays of arguments for every different debugging scenario was annoying and error-prone."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2026-01-07T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-07T00:00:00+00:00"><meta property="article:tag" content="Openqa"><meta property="article:tag" content="Automation"><meta property="article:tag" content="Python"><meta property="article:tag" content="Devops"><meta property="article:tag" content="Testing"><meta property="article:tag" content="Scripting"><meta name=twitter:card content="summary"><meta name=twitter:title content="Automating OpenQA Job Cloning with Python and YAML"><meta name=twitter:description content="üéâ Happy New Year!
As anyone working with OpenQA knows, it is a powerful tool for automated testing. But sometimes, the workflow around re-triggering those tests for investigation purposes can feel a bit&mldr; Manual.
Recently, I found myself in a repetitive cycle while debugging complex test scenarios. My workflow looked something like this:

Take a known &ldquo;good&rdquo; job URL.
Open a scratchpad editor.
Craft a long openqa-clone-job command with tons of specific override parameters (BUILD=0, custom git branches, skipping specific modules, etc.).
Run the command in the terminal, wait for the output.
Painfully visual scan of the terminal output, to identify the newly created job URLs, and select them with my mouse, to copy them.
Paste them into openqa-mon or a text file to track their progress.

Till now I used a Bash script that kind of helped, but modifying giant arrays of arguments for every different debugging scenario was annoying and error-prone."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"Automating OpenQA Job Cloning with Python and YAML","item":"https://ilmanzo.github.io/post/automating_job_cloning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Automating OpenQA Job Cloning with Python and YAML","name":"Automating OpenQA Job Cloning with Python and YAML","description":"üéâ Happy New Year! As anyone working with OpenQA knows, it is a powerful tool for automated testing. But sometimes, the workflow around re-triggering those tests for investigation purposes can feel a bit\u0026hellip; Manual.\nRecently, I found myself in a repetitive cycle while debugging complex test scenarios. My workflow looked something like this:\nTake a known \u0026ldquo;good\u0026rdquo; job URL. Open a scratchpad editor. Craft a long openqa-clone-job command with tons of specific override parameters (BUILD=0, custom git branches, skipping specific modules, etc.). Run the command in the terminal, wait for the output. Painfully visual scan of the terminal output, to identify the newly created job URLs, and select them with my mouse, to copy them. Paste them into openqa-mon or a text file to track their progress. Till now I used a Bash script that kind of helped, but modifying giant arrays of arguments for every different debugging scenario was annoying and error-prone.\n","keywords":["openQA","automation","python","devops","testing","scripting"],"articleBody":"üéâ Happy New Year! As anyone working with OpenQA knows, it is a powerful tool for automated testing. But sometimes, the workflow around re-triggering those tests for investigation purposes can feel a bit‚Ä¶ Manual.\nRecently, I found myself in a repetitive cycle while debugging complex test scenarios. My workflow looked something like this:\nTake a known ‚Äúgood‚Äù job URL. Open a scratchpad editor. Craft a long openqa-clone-job command with tons of specific override parameters (BUILD=0, custom git branches, skipping specific modules, etc.). Run the command in the terminal, wait for the output. Painfully visual scan of the terminal output, to identify the newly created job URLs, and select them with my mouse, to copy them. Paste them into openqa-mon or a text file to track their progress. Till now I used a Bash script that kind of helped, but modifying giant arrays of arguments for every different debugging scenario was annoying and error-prone.\nThen I realized that I needed to separate the configuration (the what‚Äîwhich jobs and parameters) from the execution logic (the how‚Äîrunning the command and extracting results).\nHere is how I moved from a fragile Bash script to a robust Python and YAML automation workflow.\nüéØ ‚ÄúInfrastructure as Code‚Äù for Ad-Hoc Tests I wanted a system where I could define a test scenario in a clean, readable file, run a single command, and immediately have the resulting job URLs ready for monitoring.\nStep 1: Defining the Configuration (YAML) Instead of hardcoding variables inside a script, I moved them into a structured YAML file. This makes it incredibly easy to see exactly what a specific test run is supposed to do.\nHere is an example config file, let‚Äôs call it krb5_ssh_test.yaml:\n# krb5_ssh_test.yaml # The parent jobs to clone from jobs_to_clone: - https://openqa.opensuse.org/tests/123456 - https://openqa.opensuse.org/tests/789012 # Command line flags flags: - \"--clone-children\" - \"--skip-deps\" # Environment variables and parameters variables: _GROUP_ID: 38 BUILD: \"my-custom-build\" # Pointing to my custom test branch CASEDIR: \"https://github.com/ilmanzo/os-autoinst-distri-opensuse.git#my_custom_branch\" _SKIP_POST_FAIL_HOOKS: 1 QEMURAM: 2048 This is readable, version-controllable, and easy to copy and modify for a different scenario.\nStep 2: The Automation Logic (Python) While Bash is great for gluing commands together, Python excels at parsing structured data (YAML) and handling text output (Regex).\nI wrote a Python script clone_runner.py that does three main things:\nReads the YAML config and dynamically builds the openqa-clone-job command arguments. Executes the command safely using Python‚Äôs subprocess module. Parses the output accurately. This was the key improvement: instead of me manually squinting at terminal text, Python uses regex to find lines like -\u003e https://‚Ä¶ and extracts the new URLs automatically. Here is the crucial regex function that replaced my manual copy-pasting:\ndef extract_urls(output_text: str) -\u003e List[str]: \"\"\"Parses output looking for: '- jobname -\u003e https://url...' \"\"\" url_pattern = re.compile(r\"-\u003e\\s+(https?://\\S+)\") return url_pattern.findall(output_text) The script also automatically names the output file based on the config name. If I take parameters from krb5_ssh_test.yaml, it generates krb5_ssh_test.urls.txt.\nüòá The New Workflow Now, my workflow is streamlined and consistent.\nI simply run the script pointing to my config file:\n$ ./clone_runner.py -c krb5_ssh_test.yaml Output:\n- Starting clone process using config: krb5_ssh_test.yaml - Output will be saved to: krb5_ssh_test.urls.txt Processing: [https://openqa.suse.de/tests/20438098](https://openqa.suse.de/tests/20438098) - Extracted 4 new job URLs. Processing: [https://openqa.suse.de/tests/20394793](https://openqa.suse.de/tests/20394793) - Extracted 6 new job URLs. ======================================== Success! URLs saved to 'krb5_ssh_test.urls.txt' You can now run: openqa-mon -i krb5_ssh_test.urls.txt ======================================== The final step is a seamless handoff to the monitoring tool:\n$ openqa-mon -i krb5_ssh_test.urls.txt üéá Conclusion By spending a little time moving from an imperative Bash script to a declarative YAML configuration driven by Python, I‚Äôve removed the most tedious and error-prone parts of starting ad-hoc OpenQA tests. It‚Äôs a small automation improvement that pays dividends every single day, keeping my focus on the test results rather than the command line arguments. Feel free to check the project and contribute at https://github.com/ilmanzo/openqa-clone-runner\n","wordCount":"635","inLanguage":"en","datePublished":"2026-01-07T00:00:00Z","dateModified":"2026-01-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/automating_job_cloning/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Automating OpenQA Job Cloning with Python and YAML</h1><div class=post-meta><span title='2026-01-07 00:00:00 +0000 UTC'>January 7, 2026</span></div></header><div class=post-content><h2 id=-happy-new-year>üéâ Happy New Year!<a hidden class=anchor aria-hidden=true href=#-happy-new-year>#</a></h2><p>As anyone working with <a href=https://open.qa/>OpenQA</a> knows, it is a powerful tool for automated testing. But sometimes, the workflow around re-triggering those tests for investigation purposes can feel a bit&mldr; <em>Manual</em>.</p><p>Recently, I found myself in a repetitive cycle while debugging complex test scenarios. My workflow looked something like this:</p><ul><li>Take a known &ldquo;good&rdquo; job URL.</li><li>Open a scratchpad editor.</li><li>Craft a long <code>openqa-clone-job</code> command with tons of specific override parameters (<code>BUILD=0</code>, custom git branches, skipping specific modules, etc.).</li><li>Run the command in the terminal, wait for the output.</li><li><strong>Painfully visual scan of the terminal output</strong>, to identify the newly created job URLs, and select them with my mouse, to copy them.</li><li>Paste them into <a href=https://github.com/os-autoinst/openqa-mon><code>openqa-mon</code></a> or a text file to track their progress.</li></ul><p>Till now I used a <code>Bash</code> script that kind of helped, but modifying giant arrays of arguments for every different debugging scenario was annoying and error-prone.</p><p>Then I realized that I needed to separate the <strong>configuration</strong> (the <em>what</em>‚Äîwhich jobs and parameters) from the <strong>execution logic</strong> (the <em>how</em>‚Äîrunning the command and extracting results).</p><p>Here is how I moved from a fragile Bash script to a robust <code>Python</code> and <code>YAML</code> automation workflow.</p><p><img alt=messy_desk loading=lazy src=https://www.theladders.com/wp-content/uploads/messy-desk-800x450.jpg></p><h2 id=-infrastructure-as-code-for-ad-hoc-tests>üéØ &ldquo;Infrastructure as Code&rdquo; for Ad-Hoc Tests<a hidden class=anchor aria-hidden=true href=#-infrastructure-as-code-for-ad-hoc-tests>#</a></h2><p>I wanted a system where I could define a test scenario in a clean, readable file, run a single command, and immediately have the resulting job URLs ready for monitoring.</p><h3 id=step-1-defining-the-configuration-yaml>Step 1: Defining the Configuration (YAML)<a hidden class=anchor aria-hidden=true href=#step-1-defining-the-configuration-yaml>#</a></h3><p>Instead of hardcoding variables inside a script, I moved them into a structured YAML file. This makes it incredibly easy to see exactly what a specific test run is supposed to do.</p><p>Here is an example config file, let&rsquo;s call it <code>krb5_ssh_test.yaml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># krb5_ssh_test.yaml</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># The parent jobs to clone from</span>
</span></span><span style=display:flex><span><span style=color:#f92672>jobs_to_clone</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>https://openqa.opensuse.org/tests/123456</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>https://openqa.opensuse.org/tests/789012</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Command line flags</span>
</span></span><span style=display:flex><span><span style=color:#f92672>flags</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;--clone-children&#34;</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;--skip-deps&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Environment variables and parameters</span>
</span></span><span style=display:flex><span><span style=color:#f92672>variables</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>_GROUP_ID</span>: <span style=color:#ae81ff>38</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>BUILD</span>: <span style=color:#e6db74>&#34;my-custom-build&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Pointing to my custom test branch</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>CASEDIR</span>: <span style=color:#e6db74>&#34;https://github.com/ilmanzo/os-autoinst-distri-opensuse.git#my_custom_branch&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>_SKIP_POST_FAIL_HOOKS</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>QEMURAM</span>: <span style=color:#ae81ff>2048</span>
</span></span></code></pre></div><p>This is readable, version-controllable, and easy to copy and modify for a different scenario.</p><h3 id=step-2-the-automation-logic-python>Step 2: The Automation Logic (Python)<a hidden class=anchor aria-hidden=true href=#step-2-the-automation-logic-python>#</a></h3><p>While <code>Bash</code> is great for gluing commands together, <code>Python</code> excels at parsing structured data (YAML) and handling text output (Regex).</p><p>I wrote a Python script <a href=https://github.com/ilmanzo/openqa-clone-runner>clone_runner.py</a> that does three main things:</p><ul><li>Reads the YAML config and dynamically builds the <code>openqa-clone-job</code> command arguments.</li><li>Executes the command safely using Python&rsquo;s subprocess module.</li><li>Parses the output accurately. This was the key improvement: instead of me manually squinting at terminal text, <code>Python</code> uses regex to find lines like -> https://&mldr; and extracts the new URLs automatically.</li></ul><p>Here is the crucial regex function that replaced my manual copy-pasting:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>extract_urls</span>(output_text: str) <span style=color:#f92672>-&gt;</span> List[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Parses output looking for: &#39;- jobname -&gt; https://url...&#39; &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    url_pattern <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;-&gt;\s+(https?://\S+)&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> url_pattern<span style=color:#f92672>.</span>findall(output_text)
</span></span></code></pre></div><p>The script also automatically names the output file based on the config name. If I take parameters from <code>krb5_ssh_test.yaml</code>, it generates <code>krb5_ssh_test.urls.txt</code>.</p><h2 id=-the-new-workflow>üòá The New Workflow<a hidden class=anchor aria-hidden=true href=#-the-new-workflow>#</a></h2><p>Now, my workflow is streamlined and consistent.</p><p>I simply run the script pointing to my config file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ ./clone_runner.py -c krb5_ssh_test.yaml
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>- Starting clone process using config: krb5_ssh_test.yaml
</span></span><span style=display:flex><span>- Output will be saved to: krb5_ssh_test.urls.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Processing: [https://openqa.suse.de/tests/20438098](https://openqa.suse.de/tests/20438098)
</span></span><span style=display:flex><span>   - Extracted 4 new job URLs.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Processing: [https://openqa.suse.de/tests/20394793](https://openqa.suse.de/tests/20394793)
</span></span><span style=display:flex><span>   - Extracted 6 new job URLs.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>========================================
</span></span><span style=display:flex><span>Success! URLs saved to &#39;krb5_ssh_test.urls.txt&#39;
</span></span><span style=display:flex><span>You can now run:
</span></span><span style=display:flex><span>   openqa-mon -i krb5_ssh_test.urls.txt
</span></span><span style=display:flex><span>========================================
</span></span></code></pre></div><p>The final step is a seamless handoff to the monitoring tool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span>$ openqa-mon -i krb5_ssh_test.urls.txt
</span></span></code></pre></div><h2 id=-conclusion>üéá Conclusion<a hidden class=anchor aria-hidden=true href=#-conclusion>#</a></h2><p>By spending a little time moving from an imperative Bash script to a declarative YAML configuration driven by Python, I&rsquo;ve removed the most tedious and error-prone parts of starting ad-hoc <a href=https://open.qa/>OpenQA</a> tests.
It‚Äôs a small automation improvement that pays dividends every single day, keeping my focus on the test results rather than the command line arguments.
Feel free to check the project and contribute at <a href=https://github.com/ilmanzo/openqa-clone-runner>https://github.com/ilmanzo/openqa-clone-runner</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/openqa/>Openqa</a></li><li><a href=https://ilmanzo.github.io/tags/automation/>Automation</a></li><li><a href=https://ilmanzo.github.io/tags/python/>Python</a></li><li><a href=https://ilmanzo.github.io/tags/devops/>Devops</a></li><li><a href=https://ilmanzo.github.io/tags/testing/>Testing</a></li><li><a href=https://ilmanzo.github.io/tags/scripting/>Scripting</a></li></ul><nav class=paginav><a class=next href=https://ilmanzo.github.io/post/advent_of_code_2025/><span class=title>Next ¬ª</span><br><span>Advent of code 2025: the diaries</span></a></nav></footer></article></main><footer class=footer><span>¬© 2012-2025 Andrea Manzini</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>