<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fault Injection in Network Namespace and Veth Environments | ilManzo's blog</title><meta name=keywords content="linux,sysadmin,programming,testing,device,network,namespace"><meta name=description content="How to improve your software by simulating a faulty network device"><meta name=author content="Andrea Manzini"><link rel=canonical href=https://ilmanzo.github.io/post/faulty_network_simulation/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ilmanzo.github.io/post/faulty_network_simulation/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL")}</script><meta property="og:url" content="https://ilmanzo.github.io/post/faulty_network_simulation/"><meta property="og:site_name" content="ilManzo's blog"><meta property="og:title" content="Fault Injection in Network Namespace and Veth Environments"><meta property="og:description" content="How to improve your software by simulating a faulty network device"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-01-06T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-06T00:00:00+00:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Sysadmin"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Testing"><meta property="article:tag" content="Device"><meta property="article:tag" content="Network"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fault Injection in Network Namespace and Veth Environments"><meta name=twitter:description content="How to improve your software by simulating a faulty network device"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"Fault Injection in Network Namespace and Veth Environments","item":"https://ilmanzo.github.io/post/faulty_network_simulation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Fault Injection in Network Namespace and Veth Environments","name":"Fault Injection in Network Namespace and Veth Environments","description":"How to improve your software by simulating a faulty network device","keywords":["linux","sysadmin","programming","testing","device","network","namespace"],"articleBody":"Prelude This is a followup from my previous post and a sort of continuation on the series of the topic, where we are exploring ways to make our test system more â€œunreliableâ€ in order to observe if our applications behave nicely under challenging and not-ideal environments.\nIn this article we are going to explore some linux technologies:\nNetwork Namespaces (netns) Virtual Ethernet Devices (veth) Network Emulation (netem) scheduling policy The goal is to setup a virtual network link inside our system, make the two network devices talk each other and then simulate a bad/slow/glitchy/flaky communication to test how applications behave under difficult conditions.\nReady to play and break something ?\nImage credits: Abdulvahap Demir\nSetup netns Network namespaces represent a core technology essential for containers, enabling the establishment of segregated network environments within a Linux system. They facilitate the creation of distinct network stacks for processes, including interfaces, routing tables, and firewall rules. This segregation guarantees that processes within one network namespace remain separate and insulated from those in other namespaces.\nto create and manage netns we just need the ip command:\n$ ip netns add ns_1 $ ip netns add ns_2 With this commands we just configured an empty space, now we need to place something inside.\nSetup virtual ethernet Veth devices, abbreviated from virtual Ethernet devices, are dual virtual network interfaces employed to link network namespaces. Each pair comprises two endpoints: one within a specific namespace and the other in a separate namespace. These virtual interfaces mimic Ethernet cables, enabling seamless communication between the interconnected namespaces. Traffic can traverse this veth pair bidirectionally, facilitating two-way transmission.\n$ ip link add veth_1 type veth peer name veth_2 $ ip link set veth_1 netns ns_1 $ ip link set veth_2 netns ns_2 $ ip netns exec ns_1 ip link set dev veth_1 up $ ip netns exec ns_2 ip link set dev veth_2 up note: ip netns ns_1 exec COMMAND is an handy shorthand for executing a single command in a specific namespace.\nInside your machine, there now will be two new independent namespaces, each with its own virtual network card, totally separate from the host environment:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Linux machine â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ ns_1 â”‚ â”‚ ns_2 â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ â”‚ â”‚ â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ veth_1 â”‚ â”‚ veth_2 â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Addressing So far your virtual devices does not yet have any IP address, even loopback is down:\n$ ip -all netns exec ip link show netns: ns_1 1: lo: mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 9: veth_1@if8: mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000 link/ether 52:69:cf:de:7d:10 brd ff:ff:ff:ff:ff:ff link-netns ns_2 netns: ns_2 1: lo: mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 8: veth_2@if9: mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000 link/ether 6e:19:3c:20:e0:9a brd ff:ff:ff:ff:ff:ff link-netns ns_1 letâ€™s give them a random IPV4 on the same subnet:\n$ ip netns exec ns_1 ip addr add 10.1.1.1/24 dev veth_1 $ ip netns exec ns_2 ip addr add 10.1.1.2/24 dev veth_2 The cool thing now is that we can reach the other end only via namespace. Just to be clear, this is not going to work:\n$ ping -c 3 10.1.1.2 PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data. --- 10.1.1.2 ping statistics --- 3 packets transmitted, 0 received, 100% packet loss, time 2020ms Why ? Because we need to run ping command from the proper namespace:\n$ ip netns exec ns_1 ping -c 3 10.1.1.2 PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data. 64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.040 ms 64 bytes from 10.1.1.2: icmp_seq=2 ttl=64 time=0.044 ms 64 bytes from 10.1.1.2: icmp_seq=3 ttl=64 time=0.057 ms --- 10.1.1.2 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2021ms rtt min/avg/max/mdev = 0.040/0.047/0.057/0.007 ms Looking at those rtt numbers, this virtual network seems working fast and smooth, so itâ€™s time to break somethingâ€¦ ğŸ˜ˆ\nFault injection Letâ€™s add a 50ms Â± 25ms random delay to each packet on one side:\n$ ip netns exec ns_1 tc qdisc add dev veth_1 root netem delay 50ms 25ms on the other side, we also simulate a 50% chance of a dropped packed, with a 25% chance of subsequent packet loss (to emulate packet burst losses)\n$ ip netns exec ns_2 tc qdisc add dev veth_2 root netem loss 50% 25% How the ping will do ? Pretty bad indeed: ğŸ‘\n$ ip netns exec ns_1 ping -c 10 10.1.1.2 PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data. 64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=66.6 ms 64 bytes from 10.1.1.2: icmp_seq=3 ttl=64 time=34.6 ms 64 bytes from 10.1.1.2: icmp_seq=4 ttl=64 time=41.6 ms 64 bytes from 10.1.1.2: icmp_seq=6 ttl=64 time=28.0 ms 64 bytes from 10.1.1.2: icmp_seq=9 ttl=64 time=51.6 ms 64 bytes from 10.1.1.2: icmp_seq=10 ttl=64 time=50.8 ms --- 10.1.1.2 ping statistics --- 10 packets transmitted, 6 received, 40% packet loss, time 9081ms rtt min/avg/max/mdev = 28.031/45.522/66.569/12.561 ms Another couple cool features of netem are Packet corruption, which simulates a single bit error at a random offset in the packet, and Packet Re-ordering, which causes a certain percentage of the packets to arrive in a wrong order. For any detail, you can consult the tc-netem(8) man page.\nWrap and clean up We ended with a simulated network where we can control packet loss and delay / jitter , we can do any experiment we need by running our services in the proper namespace.\nWhen we are finished, if we donâ€™t have any other namespace defined, itâ€™s simple to remove every track from our system with a single command:\n$ ip --all netns del ","wordCount":"1019","inLanguage":"en","datePublished":"2024-01-06T00:00:00Z","dateModified":"2024-01-06T00:00:00Z","author":{"@type":"Person","name":"Andrea Manzini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/faulty_network_simulation/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Fault Injection in Network Namespace and Veth Environments</h1><div class=post-description>How to improve your software by simulating a faulty network device</div><div class=post-meta><span title='2024-01-06 00:00:00 +0000 UTC'>January 6, 2024</span>&nbsp;Â·&nbsp;Andrea Manzini</div></header><div class=post-content><h2 id=prelude>Prelude<a hidden class=anchor aria-hidden=true href=#prelude>#</a></h2><p>This is a followup from my <a href=https://ilmanzo.github.io/post/faulty_disk_simulation/>previous post</a> and a sort of continuation on the series of the topic, where we are exploring ways to make our test system more &ldquo;unreliable&rdquo; in order to observe if our applications behave nicely under challenging and not-ideal environments.</p><p>In this article we are going to explore some linux technologies:</p><ul><li>Network Namespaces (<strong>netns</strong>)</li><li>Virtual Ethernet Devices (<strong>veth</strong>)</li><li>Network Emulation (<strong>netem</strong>) scheduling policy</li></ul><p>The goal is to setup a virtual network link inside our system, make the two network devices talk each other and then simulate a <em>bad/slow/glitchy/flaky</em> communication to test how applications behave under difficult conditions.</p><p>Ready to play and break something ?</p><p><img alt="broken network" loading=lazy src=/img/pexels-broken-net-14839933.jpeg>
Image credits: <a href=https://www.pexels.com/@infovahapdmr/>Abdulvahap Demir</a></p><h2 id=setup-netns>Setup netns<a hidden class=anchor aria-hidden=true href=#setup-netns>#</a></h2><p>Network namespaces represent a core technology essential for containers, enabling the establishment of segregated network environments within a Linux system. They facilitate the creation of distinct network stacks for processes, including interfaces, routing tables, and firewall rules. This segregation guarantees that processes within one network namespace remain separate and insulated from those in other namespaces.</p><p>to create and manage <code>netns</code> we just need the <code>ip</code> command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip netns add ns_1
</span></span><span style=display:flex><span>$ ip netns add ns_2
</span></span></code></pre></div><p>With this commands we just configured an empty space, now we need to place something inside.</p><h2 id=setup-virtual-ethernet>Setup virtual ethernet<a hidden class=anchor aria-hidden=true href=#setup-virtual-ethernet>#</a></h2><p>Veth devices, abbreviated from virtual Ethernet devices, are dual virtual network interfaces employed to link network namespaces. Each pair comprises two endpoints: one within a specific namespace and the other in a separate namespace. These virtual interfaces mimic Ethernet cables, enabling seamless communication between the interconnected namespaces. Traffic can traverse this veth pair bidirectionally, facilitating two-way transmission.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip link add veth_1 type veth peer name veth_2
</span></span><span style=display:flex><span>$ ip link set veth_1 netns ns_1
</span></span><span style=display:flex><span>$ ip link set veth_2 netns ns_2
</span></span><span style=display:flex><span>$ ip netns exec ns_1 ip link set dev veth_1 up
</span></span><span style=display:flex><span>$ ip netns exec ns_2 ip link set dev veth_2 up
</span></span></code></pre></div><p>note: <code>ip netns ns_1 exec COMMAND</code> is an handy shorthand for executing a single command in a specific namespace.</p><p>Inside your machine, there now will be <em>two</em> new <strong>independent</strong> namespaces, each with its own virtual network card, totally separate from the <em>host</em> environment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
</span></span><span style=display:flex><span>          â”‚ Linux machine                                            â”‚
</span></span><span style=display:flex><span>          â”‚                                                          â”‚
</span></span><span style=display:flex><span>          â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚     ns_1     â”‚            â”‚     ns_2     â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚              â”‚            â”‚              â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚              â”‚            â”‚              â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚              â”‚            â”‚              â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚              â”‚            â”‚              â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚    â”‚         â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚    â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚    â”‚  veth_1 â”‚            â”‚ veth_2  â”‚    â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚    â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚         â”‚    â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â”‚              â”‚            â”‚              â”‚       â”‚
</span></span><span style=display:flex><span>          â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
</span></span><span style=display:flex><span>          â”‚                                                          â”‚
</span></span><span style=display:flex><span>          â”‚                                                          â”‚
</span></span><span style=display:flex><span>          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span></code></pre></div><h2 id=addressing>Addressing<a hidden class=anchor aria-hidden=true href=#addressing>#</a></h2><p>So far your virtual devices does not yet have any IP address, even loopback is down:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip -all netns exec ip link show
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>netns: ns_1
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK&gt; mtu <span style=color:#ae81ff>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>9: veth_1@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style=color:#ae81ff>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>    link/ether 52:69:cf:de:7d:10 brd ff:ff:ff:ff:ff:ff link-netns ns_2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>netns: ns_2
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK&gt; mtu <span style=color:#ae81ff>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>8: veth_2@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style=color:#ae81ff>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>    link/ether 6e:19:3c:20:e0:9a brd ff:ff:ff:ff:ff:ff link-netns ns_1
</span></span></code></pre></div><p>let&rsquo;s give them a random IPV4 on the same subnet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip netns exec ns_1 ip addr add 10.1.1.1/24 dev veth_1 
</span></span><span style=display:flex><span>$ ip netns exec ns_2 ip addr add 10.1.1.2/24 dev veth_2
</span></span></code></pre></div><p>The cool thing now is that we can reach the other end only via namespace. Just to be clear, this is not going to work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ping -c <span style=color:#ae81ff>3</span> 10.1.1.2 
</span></span><span style=display:flex><span>PING 10.1.1.2 <span style=color:#f92672>(</span>10.1.1.2<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 10.1.1.2 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> packets transmitted, <span style=color:#ae81ff>0</span> received, 100% packet loss, time 2020ms
</span></span></code></pre></div><p>Why ? Because we need to run <code>ping</code> command from the proper namespace:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip netns exec ns_1 ping -c <span style=color:#ae81ff>3</span> 10.1.1.2
</span></span><span style=display:flex><span>PING 10.1.1.2 <span style=color:#f92672>(</span>10.1.1.2<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.040 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.044 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.057 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 10.1.1.2 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> packets transmitted, <span style=color:#ae81ff>3</span> received, 0% packet loss, time 2021ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.040/0.047/0.057/0.007 ms
</span></span></code></pre></div><p>Looking at those rtt numbers, this virtual network seems working fast and smooth, so it&rsquo;s time to break something&mldr; ğŸ˜ˆ</p><h2 id=fault-injection>Fault injection<a hidden class=anchor aria-hidden=true href=#fault-injection>#</a></h2><p>Let&rsquo;s add a 50ms Â± 25ms random delay to each packet on one side:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip netns exec ns_1 tc qdisc add dev veth_1 root netem delay 50ms 25ms
</span></span></code></pre></div><p>on the other side, we also simulate a 50% chance of a dropped packed, with a 25% chance of subsequent packet loss (to emulate packet burst losses)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip netns exec ns_2 tc qdisc add dev veth_2 root netem loss 50% 25%
</span></span></code></pre></div><p>How the ping will do ? Pretty <em>bad</em> indeed: ğŸ‘</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip netns exec ns_1 ping -c <span style=color:#ae81ff>10</span> 10.1.1.2
</span></span><span style=display:flex><span>PING 10.1.1.2 <span style=color:#f92672>(</span>10.1.1.2<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>66.6 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>34.6 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>41.6 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>28.0 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>9</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>51.6 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.1.1.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>50.8 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 10.1.1.2 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>10</span> packets transmitted, <span style=color:#ae81ff>6</span> received, 40% packet loss, time 9081ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 28.031/45.522/66.569/12.561 ms
</span></span></code></pre></div><p>Another couple cool features of <code>netem</code> are <strong>Packet corruption</strong>, which simulates a single bit error at a random offset in the packet, and <strong>Packet Re-ordering</strong>, which causes a certain percentage of the packets to arrive in a wrong order. For any detail, you can consult the <code>tc-netem(8)</code> <a href=https://man7.org/linux/man-pages/man8/tc-netem.8.html>man page</a>.</p><h2 id=wrap-and-clean-up>Wrap and clean up<a hidden class=anchor aria-hidden=true href=#wrap-and-clean-up>#</a></h2><p>We ended with a simulated network where we can control packet loss and delay / jitter , we can do any experiment we need by running our services in the proper namespace.</p><p>When we are finished, if we don&rsquo;t have any other namespace defined, it&rsquo;s simple to remove every track from our system with a single command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ip --all netns del
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/linux/>Linux</a></li><li><a href=https://ilmanzo.github.io/tags/sysadmin/>Sysadmin</a></li><li><a href=https://ilmanzo.github.io/tags/programming/>Programming</a></li><li><a href=https://ilmanzo.github.io/tags/testing/>Testing</a></li><li><a href=https://ilmanzo.github.io/tags/device/>Device</a></li><li><a href=https://ilmanzo.github.io/tags/network/>Network</a></li><li><a href=https://ilmanzo.github.io/tags/namespace/>Namespace</a></li></ul><nav class=paginav><a class=prev href=https://ilmanzo.github.io/post/introduction_to_packaging_rust_applications/><span class=title>Â« Prev</span><br><span>Introduction to packaging Rust application</span>
</a><a class=next href=https://ilmanzo.github.io/post/faulty_disk_simulation/><span class=title>Next Â»</span><br><span>Expect the unexpected</span></a></nav></footer></article></main><footer class=footer><span>Â© 2012-2025 Andrea Manzini</span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>