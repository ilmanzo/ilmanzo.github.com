<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How much code are you testing ? (2) | ilManzo's blog</title><meta name=keywords content="testing,tutorial,linux,coverage,e2e,qa,tracing,scripting"><meta name=description content="Measuring test coverage on binaries"><meta name=author content="Andrea Manzini"><link rel=canonical href=https://ilmanzo.github.io/post/measuring-test-coverage-on-binaries/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ilmanzo.github.io/post/measuring-test-coverage-on-binaries/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL")}</script><meta property="og:url" content="https://ilmanzo.github.io/post/measuring-test-coverage-on-binaries/"><meta property="og:site_name" content="ilManzo's blog"><meta property="og:title" content="How much code are you testing ? (2)"><meta property="og:description" content="Measuring test coverage on binaries"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-03-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-30T00:00:00+00:00"><meta property="article:tag" content="Testing"><meta property="article:tag" content="Tutorial"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Coverage"><meta property="article:tag" content="E2e"><meta property="article:tag" content="Qa"><meta name=twitter:card content="summary"><meta name=twitter:title content="How much code are you testing ? (2)"><meta name=twitter:description content="Measuring test coverage on binaries"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"How much code are you testing ? (2)","item":"https://ilmanzo.github.io/post/measuring-test-coverage-on-binaries/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How much code are you testing ? (2)","name":"How much code are you testing ? (2)","description":"Measuring test coverage on binaries","keywords":["testing","tutorial","linux","coverage","e2e","qa","tracing","scripting"],"articleBody":"‚ñ∂Ô∏è Intro On the previous post we started our journey with a very simple scenario, and we used a nice feature of the Go programming language to get a measure of how much % of the target program our test is exercising.\nThis time I am going to experiment a Proof of Concept about how we can obtain a test code coverage metric estimation for a normal binary program, without any recompilation.\nIn this example we will pretend that our task is to write integration tests for the famous gzip program, and try to measure the progresses we are doing about coverage of our tests.\nEven pets need coverage! Image credits to: Em Hopper\nüßÆ How ? The main idea is\nget in some way the complete list of functions present in the program = N record, during test, which of those functions are executed = E The ratio E/N provides an approximation of test effectiveness, driving us toward areas needing coverage expansion.\nWe don‚Äôt want to recompile gzip with coverage instrumentation, but in our distro we have the debug information of the program. Usually they are provided in separate packages, and the repository is not enabled by default, so first of all let‚Äôs enable them and install the related packages. On Tumbleweed:\n$ sudo zypper modifyrepo -e repo-debug $ sudo zypper refresh $ sudo zypper in gzip-debuginfo gzip-debugsource üëê Functions all the way down We can use the gdb debugger to have a list of all the functions in a program:\n$ sudo zypper install gdb $ gdb /usr/bin/gzip For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from /usr/bin/gzip... Reading symbols from /usr/lib/debug/usr/bin/gzip.debug... (gdb) info functions All defined functions: File ../sysdeps/x86_64/start.S: void _start(void); File ./lib/stat-time.h: 29: int openat_safer(int, const char *, int, ...); 30: int rpl_printf(const char *, ...); 116: int unzip(int, int); [... long output omitted ...] That looks promising!\n‚òùÔ∏è Write the first test As we did last time, for simplicity we are going to use the pytest framework, but any other would work. First, let‚Äôs write a smoke test:\n# test_gzip.py import os,re from subprocess import run PROGRAM='/usr/bin/gzip' # program should display help def test_help(capfd): process=run([PROGRAM,'-h']) stdout, stderr = capfd.readouterr() assert process.returncode == 0 assert \"Usage:\" in stdout On this test, we spawn a process to simply execute gzip -h, expecting some specific output. let‚Äôs run it:\n============================= test session starts ============================== platform linux -- Python 3.13.2, pytest-8.3.4, pluggy-1.5.0 rootdir: /home/andrea/binarycoverage collected 1 item test_gzip.py . [100%] ============================== 1 passed in 0.01s =============================== üë£ Trace it Now we can trace which functions have been exercised by wrapping the test run with the powerful valgrind tool:\n$ sudo zypper install valgrind $ valgrind --tool=callgrind --trace-children=yes pytest the execution takes a bit longer and we get some new files which contains tracing data:\n$ ls -l callgrind.out.* -rw-------. 1 andrea andrea 1944681 Mar 30 17:54 callgrind.out.2771 -rw-------. 1 andrea andrea 82977 Mar 30 17:54 callgrind.out.2816 These data files are intended to be processed by callgrind_annotate that will output a detailed report with all the functions executed (including those in libraries like glibc).\n$ callgrind_annotate callgrind.out.2816 -------------------------------------------------------------------------------- Profile data file 'callgrind.out.2816' (creator: callgrind-3.24.0) -------------------------------------------------------------------------------- I1 cache: D1 cache: LL cache: Timerange: Basic block 0 - 52685 Trigger: Program termination Profiled target: /usr/bin/gzip -h (PID 2816, part 1) Events recorded: Ir Events shown: Ir Event sort order: Ir Thresholds: 99 Include dirs: User annotated: Auto-annotation: on -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 246,004 (100.0%) PROGRAM TOTALS -------------------------------------------------------------------------------- Ir file:function -------------------------------------------------------------------------------- 41,382 (16.82%) /usr/src/debug/glibc-2.41/elf/dl-lookup.c:do_lookup_x [/usr/lib64/ld-linux-x86-64.so.2] 40,596 (16.50%) /usr/src/debug/glibc-2.41/elf/dl-reloc.c:_dl_relocate_object_no_relro [/usr/lib64/ld-linux-x86-64.so.2] 17,388 ( 7.07%) /usr/src/debug/glibc-2.41/elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib64/ld-linux-x86-64.so.2] 13,781 ( 5.60%) /usr/src/debug/glibc-2.41/elf/dl-tunables.c:__GI___tunables_init [/usr/lib64/ld-linux-x86-64.so.2] 13,309 ( 5.41%) /usr/src/debug/glibc-2.41/elf/../sysdeps/generic/dl-new-hash.h:_dl_lookup_symbol_x 11,941 ( 4.85%) /usr/src/debug/glibc-2.41/string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S:strcmp [/usr/lib64/ld-linux-x86-64.so.2] 9,951 ( 4.05%) /usr/src/debug/glibc-2.41/elf/dl-lookup.c:check_match [/usr/lib64/ld-linux-x86-64.so.2] 8,321 ( 3.38%) /usr/src/debug/glibc-2.41/elf/do-rel.h:_dl_relocate_object_no_relro 7,033 ( 2.86%) /usr/src/debug/gzip-1.13/lib/vasnprintf.c:vasnprintf [/usr/bin/gzip] 6,968 ( 2.83%) /usr/src/debug/glibc-2.41/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object_no_relro 5,935 ( 2.41%) /usr/src/debug/glibc-2.41/elf/../sysdeps/x86/dl-cacheinfo.h:intel_check_word.constprop.0 [/usr/lib64/ld-linux-x86-64.so.2] 4,811 ( 1.96%) /usr/src/debug/glibc-2.41/elf/../bits/stdlib-bsearch.h:intel_check_word.constprop.0 4,402 ( 1.79%) /usr/src/debug/glibc-2.41/elf/dl-version.c:_dl_check_map_versions [/usr/lib64/ld-linux-x86-64.so.2] 4,356 ( 1.77%) /usr/src/debug/glibc-2.41/elf/dl-tunables.h:__GI___tunables_init 4,348 ( 1.77%) /usr/src/debug/gzip-1.13/lib/printf-parse.c:vasnprintf 2,660 ( 1.08%) /usr/src/debug/glibc-2.41/stdio-common/vfprintf-internal.c:__printf_buffer [/usr/lib64/libc.so.6] 2,064 ( 0.84%) /usr/src/debug/glibc-2.41/stdio-common/Xprintf_buffer_write.c:__printf_buffer_write [/usr/lib64/libc.so.6] While a bit verbose, it contains all the information we need. It just needs some massaging ‚Ä¶\nü§ñ Automate it To make our life easier, better use some glue scripting to automate the tools and parse the data with some python code to get the information we need. The complete project is available on my GitHub repository, but here an excerpt of the script coverage.sh that runs pytest and outputs coverage measure:\n#!/bin/bash BINARY=gzip TEMP_DIR=$(mktemp -d) valgrind --tool=callgrind --trace-children=yes \\ --callgrind-out-file=$TEMP_DIR/callgrind.%p pytest 2\u003e /dev/null # dump all the functions in the binary gdb -ex 'set pagination off' -ex 'info functions' -ex quit \\ $(which $BINARY) \u003e $TEMP_DIR/all_funcs.gdb python3 calc_coverage.py --binary $BINARY -d $TEMP_DIR # Clean up: Remove the temporary directory and its contents rm -rf \"$TEMP_DIR\" \u003e ./coverage.sh ============================= test session starts ============================== platform linux -- Python 3.13.2, pytest-8.3.4, pluggy-1.5.0 rootdir: /home/andrea/binarycoverage collected 1 item test_gzip.py . [100%] ============================== 1 passed in 0.54s =============================== --- Binary coverage report --- Functions coverage: 9/80 11.25% As expected, our ‚Äúsmoke‚Äù test on gzip runs only 9 functions of 80, with a low 11% coverage.\nüèÉ‚Äç‚û°Ô∏è Let‚Äôs move forward Now we can improve our testing, as we are driven by the coverage metric. Shall we try with gzip -V option ?\n# program should display version information def test_version(capfd): process=run([PROGRAM,'-V']) stdout, stderr = capfd.readouterr() assert process.returncode == 0 assert \"This is free software\" in stdout assert re.search(r\"gzip \\d.\\d\\d\", stdout) A simple test to ensure the program outputs a numeric version.\n$ ./coverage.sh ============================= test session starts ============================== collected 2 items test_gzip.py .. [100%] ============================== 2 passed in 1.17s =============================== --- Binary coverage report --- Functions coverage: 10/80 12.50% A bit better! Let‚Äôs add a negative test for good measure:\n# program should fail when given a non existing file def test_compress_non_existent(): process=run([PROGRAM,'foobar']) assert process.returncode==1 $ ./coverage.sh ============================= test session starts ============================== collected 3 items test_gzip.py ... [100%] ============================== 3 passed in 1.51s =============================== --- Binary coverage report --- Functions coverage: 19/80 23.75% We are on a good track. We doubled the coverage, and still we haven‚Äôt compressed anything‚Ä¶\nüèãÔ∏è Do some actual work Time to write a test to compress and decompress a file! We introduce also an helper function in the test, as we will need it more than once:\nSAMPLE_FILE='sample.txt' # program should compress and de-compress a file def test_compress_decompress(capfd): create_test_file(SAMPLE_FILE) with open(SAMPLE_FILE) as file: content=file.readlines() process=run([PROGRAM,SAMPLE_FILE]) assert process.returncode == 0 compressed_file=SAMPLE_FILE+\".gz\" # decompress and read back content process=run([PROGRAM,'-d',compressed_file]) assert process.returncode == 0 with open(SAMPLE_FILE) as file: assert(file.readlines()==content) os.remove(SAMPLE_FILE) # helper function to create a dummy sample file def create_test_file(file_name): sample_text = \"\"\"This is a dummy sample text file. It contains some random lines of text. This is line 3 of the text file. Here is line 4, just for testing purposes. Feel free to modify or extend this text. \"\"\" # Open the file in write mode ('w') and write the sample text to it with open(file_name, 'w') as file: file.write(sample_text) \u003e ./coverage.sh ============================= test session starts ============================== collected 4 items test_gzip.py .... [100%] ============================== 4 passed in 2.30s =============================== --- Binary coverage report --- Functions coverage: 52/80 65.00% That‚Äôs a big progress! Our tests are getting better. Just one more ? Get to the evil side and give it a damaged file:\n# program should give error on a damaged compressed file def test_decompress_error(capfd): wrong_file='dummy.txt' create_test_file(wrong_file) wrong_compressed=wrong_file+'.gz' process=run([PROGRAM,wrong_file]) # now damage the compressed file by writing a random byte with open(wrong_compressed, \"r+b\") as file: file.seek(32) file.write(bytes(0xFF)) # decompression should fail process=run([PROGRAM,'-d',wrong_compressed]) stdout, stderr = capfd.readouterr() assert process.returncode==1 assert 'invalid compressed data' in stderr os.remove(wrong_file+'.gz') $ ./coverage.sh ============================= test session starts ============================== collected 5 items test_gzip.py ..... [100%] ============================== 5 passed in 3.02s =============================== --- Binary coverage report --- Functions coverage: 54/80 67.50% That‚Äôs some good number! Can you think of some areas of improvement ?\nüëì We miss something If you use the -v verbose option, the python calc_coverage script will output the functions which are tested and which aren‚Äôt:\nExecuted functions: atdir_eq,atdir_set,bi_windup,build_tree,compress_block,ct_tally,discard_input_bytes,do_exit,fd_safer,file_read,fill_inbuf,fill_window,finish_out,finish_up_gzip,flush_block,flush_outbuf,flush_window,gen_codes,get_input_size_and_time,get_method,get_suffix,huft_build,huft_free,inflate_codes,inflate_dynamic,init_block,input_eof,last_component,license,longest_match,main,open_and_stat,open_safer,openat_safer,pqdownheap,progerror,read_buffer,remove_output_file,rpl_fclose,rpl_fflush,rpl_fprintf,rpl_printf,rpl_vfprintf,scan_tree,send_bits,send_tree,strlwr,treat_file,unzip,updcrc,vasnprintf,write_buf,xstrdup,zip Missing functions : _start,abort_gzip_signal,copy,copy_block,direntry_cmp_name,display_ratio,do_list,fillbuf,fprint_off,gzip_error,inflate_fixed,make_table,mbszero,read_byte,read_error,read_pt_len,rpl_fcntl,rsync_roll,treat_stdin,try_help,unlzh,unlzw,unpack,write_error,xalloc_die,xpalloc In this way, we have also some hints about which features of the program we aren‚Äôt testing. In this example, among others we can cite the rsync compatibility and support for .Z files. Of course, some (like the signal handling routines) are very difficult to properly test.\nüßµ Final words It‚Äôs crucial to remember that the coverage percentage obtained using this method is an approximation. valgrind tracks function calls, not individual line or branch executions. Therefore, a function might be called but not fully tested, leading to potential false positives. Additionally, functions indirectly exercised by other calls might not be explicitly listed, resulting in false negatives. The performance overhead introduced by valgrind also means this technique is more suitable for offline analysis than real-time testing.\nOn the other hand, it has the benefits that it‚Äôs simple to implement, doesn‚Äôt require big effort nor special setup and you can use it as an indication if the integration tests you are writing are improving over the time or not. Another good use can be to detect when the new version of the programs have more features, as your coverage will get lower with the update would mean you are not testing the new stuff.\nThanks for following me until the end of this long post, feel free to send comments and feedback, happy hacking! üëã\n","wordCount":"1552","inLanguage":"en","datePublished":"2025-03-30T00:00:00Z","dateModified":"2025-03-30T00:00:00Z","author":{"@type":"Person","name":"Andrea Manzini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/measuring-test-coverage-on-binaries/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">How much code are you testing ? (2)</h1><div class=post-description>Measuring test coverage on binaries</div><div class=post-meta><span title='2025-03-30 00:00:00 +0000 UTC'>March 30, 2025</span>&nbsp;¬∑&nbsp;Andrea Manzini</div></header><div class=post-content><h2 id=-intro>‚ñ∂Ô∏è Intro<a hidden class=anchor aria-hidden=true href=#-intro>#</a></h2><p>On the <a href=https://ilmanzo.github.io/post/measuring-coverage-of-integration-tests/>previous post</a> we started our journey with a very simple scenario, and we used a <a href=https://go.dev/blog/integration-test-coverage>nice feature</a> of the Go programming language to get a measure of how much % of the target program our test is exercising.</p><p>This time I am going to experiment a Proof of Concept about how we can obtain a test code coverage metric estimation for a normal binary program, <strong>without any recompilation.</strong></p><p>In this example we will pretend that our task is to write integration tests for the famous <code>gzip</code> program, and try to measure the progresses we are doing about <em>coverage</em> of our tests.</p><p><img alt=coverage loading=lazy src=/img/pexels-emhopper-1359036.jpg>
<em>Even pets need coverage!</em> Image credits to: <a href=https://www.pexels.com/@emhopper/>Em Hopper</a></p><h2 id=-how->üßÆ How ?<a hidden class=anchor aria-hidden=true href=#-how->#</a></h2><p>The main idea is</p><ul><li>get in some way the <em>complete</em> list of functions present in the program = N</li><li>record, during test, which of those functions are executed = E</li></ul><p>The ratio E/N provides an approximation of test effectiveness, driving us toward areas needing coverage expansion.</p><p>We don&rsquo;t want to recompile <code>gzip</code> with coverage instrumentation, but in our distro we have the <em>debug information</em> of the program. Usually they are provided in separate packages, and the repository is not enabled by default, so first of all let&rsquo;s enable them and install the related packages.
On Tumbleweed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo zypper modifyrepo -e repo-debug 
</span></span><span style=display:flex><span>$ sudo zypper refresh
</span></span><span style=display:flex><span>$ sudo zypper in gzip-debuginfo gzip-debugsource
</span></span></code></pre></div><h2 id=-functions-all-the-way-down>üëê Functions all the way down<a hidden class=anchor aria-hidden=true href=#-functions-all-the-way-down>#</a></h2><p>We can use the <code>gdb</code> debugger to have a list of all the functions in a program:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo zypper install gdb
</span></span><span style=display:flex><span>$ gdb /usr/bin/gzip
</span></span><span style=display:flex><span>For help, type <span style=color:#e6db74>&#34;help&#34;</span>.
</span></span><span style=display:flex><span>Type <span style=color:#e6db74>&#34;apropos word&#34;</span> to search <span style=color:#66d9ef>for</span> commands related to <span style=color:#e6db74>&#34;word&#34;</span>...
</span></span><span style=display:flex><span>Reading symbols from /usr/bin/gzip...
</span></span><span style=display:flex><span>Reading symbols from /usr/lib/debug/usr/bin/gzip.debug...
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> info functions
</span></span><span style=display:flex><span>All defined functions:
</span></span><span style=display:flex><span>File ../sysdeps/x86_64/start.S:
</span></span><span style=display:flex><span>        void _start<span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>File ./lib/stat-time.h:
</span></span><span style=display:flex><span>29:     int openat_safer<span style=color:#f92672>(</span>int, const char *, int, ...<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>30:     int rpl_printf<span style=color:#f92672>(</span>const char *, ...<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>116:    int unzip<span style=color:#f92672>(</span>int, int<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>... long output omitted ...<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>That looks promising!</p><h2 id=-write-the-first-test>‚òùÔ∏è Write the first test<a hidden class=anchor aria-hidden=true href=#-write-the-first-test>#</a></h2><p>As we did last time, for simplicity we are going to use the <code>pytest</code> framework, but <a href=https://open.qa/>any other</a> would work. First, let&rsquo;s write a <em>smoke</em> test:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># test_gzip.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os<span style=color:#f92672>,</span>re
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> subprocess <span style=color:#f92672>import</span> run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PROGRAM<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;/usr/bin/gzip&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># program should display help</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_help</span>(capfd):
</span></span><span style=display:flex><span>    process<span style=color:#f92672>=</span>run([PROGRAM,<span style=color:#e6db74>&#39;-h&#39;</span>])
</span></span><span style=display:flex><span>    stdout, stderr <span style=color:#f92672>=</span> capfd<span style=color:#f92672>.</span>readouterr()     
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> process<span style=color:#f92672>.</span>returncode <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> <span style=color:#e6db74>&#34;Usage:&#34;</span> <span style=color:#f92672>in</span> stdout 
</span></span></code></pre></div><p>On this test, we spawn a process to simply execute <code>gzip -h</code>, expecting some specific output.
let&rsquo;s run it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=============================</span> test session starts <span style=color:#f92672>==============================</span>
</span></span><span style=display:flex><span>platform linux -- Python 3.13.2, pytest-8.3.4, pluggy-1.5.0
</span></span><span style=display:flex><span>rootdir: /home/andrea/binarycoverage
</span></span><span style=display:flex><span>collected <span style=color:#ae81ff>1</span> item
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_gzip.py .                                                            <span style=color:#f92672>[</span>100%<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>==============================</span> <span style=color:#ae81ff>1</span> passed in 0.01s <span style=color:#f92672>===============================</span>
</span></span></code></pre></div><h2 id=-trace-it>üë£ Trace it<a hidden class=anchor aria-hidden=true href=#-trace-it>#</a></h2><p>Now we can trace which functions have been exercised by wrapping the test run with the powerful <a href=https://valgrind.org/><code>valgrind</code></a> tool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo zypper install valgrind
</span></span><span style=display:flex><span>$ valgrind --tool<span style=color:#f92672>=</span>callgrind --trace-children<span style=color:#f92672>=</span>yes pytest
</span></span></code></pre></div><p>the execution takes a bit longer and we get some new files which contains tracing data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ls -l callgrind.out.*
</span></span><span style=display:flex><span>-rw-------. <span style=color:#ae81ff>1</span> andrea andrea <span style=color:#ae81ff>1944681</span> Mar <span style=color:#ae81ff>30</span> 17:54 callgrind.out.2771
</span></span><span style=display:flex><span>-rw-------. <span style=color:#ae81ff>1</span> andrea andrea   <span style=color:#ae81ff>82977</span> Mar <span style=color:#ae81ff>30</span> 17:54 callgrind.out.2816
</span></span></code></pre></div><p>These data files are intended to be processed by <a href=https://valgrind.org/docs/manual/cl-manual.html#cl-manual.callgrind_annotate-options>callgrind_annotate</a>
that will output a detailed report with all the functions executed (including those in libraries like <code>glibc</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#f92672>$</span> callgrind_annotate callgrind<span style=color:#f92672>.</span>out<span style=color:#f92672>.</span><span style=color:#ae81ff>2816</span>
</span></span><span style=display:flex><span><span style=color:#f92672>--------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>Profile data file <span style=color:#e6db74>&#39;callgrind.out.2816&#39;</span> (creator: callgrind<span style=color:#f92672>-</span><span style=color:#ae81ff>3.24</span><span style=color:#f92672>.</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>--------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>I1 cache:
</span></span><span style=display:flex><span>D1 cache:
</span></span><span style=display:flex><span>LL cache:
</span></span><span style=display:flex><span>Timerange: Basic block <span style=color:#ae81ff>0</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>52685</span>
</span></span><span style=display:flex><span>Trigger: Program termination
</span></span><span style=display:flex><span>Profiled target:  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>bin<span style=color:#f92672>/</span>gzip <span style=color:#f92672>-</span>h (PID <span style=color:#ae81ff>2816</span>, part <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>Events recorded:  Ir
</span></span><span style=display:flex><span>Events shown:     Ir
</span></span><span style=display:flex><span>Event sort order: Ir
</span></span><span style=display:flex><span>Thresholds:       <span style=color:#ae81ff>99</span>
</span></span><span style=display:flex><span>Include dirs:
</span></span><span style=display:flex><span>User annotated:
</span></span><span style=display:flex><span>Auto<span style=color:#f92672>-</span>annotation:  on
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>--------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>Ir
</span></span><span style=display:flex><span><span style=color:#f92672>--------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>246</span>,<span style=color:#ae81ff>004</span> (<span style=color:#ae81ff>100.0</span><span style=color:#f92672>%</span>)  PROGRAM TOTALS
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>--------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>Ir               file:function
</span></span><span style=display:flex><span><span style=color:#f92672>--------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>41</span>,<span style=color:#ae81ff>382</span> (<span style=color:#ae81ff>16.82</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>lookup<span style=color:#f92672>.</span>c:do_lookup_x [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>ld<span style=color:#f92672>-</span>linux<span style=color:#f92672>-</span>x86<span style=color:#f92672>-</span><span style=color:#ae81ff>64.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span><span style=color:#ae81ff>40</span>,<span style=color:#ae81ff>596</span> (<span style=color:#ae81ff>16.50</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>reloc<span style=color:#f92672>.</span>c:_dl_relocate_object_no_relro [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>ld<span style=color:#f92672>-</span>linux<span style=color:#f92672>-</span>x86<span style=color:#f92672>-</span><span style=color:#ae81ff>64.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span><span style=color:#ae81ff>17</span>,<span style=color:#ae81ff>388</span> ( <span style=color:#ae81ff>7.07</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>lookup<span style=color:#f92672>.</span>c:_dl_lookup_symbol_x [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>ld<span style=color:#f92672>-</span>linux<span style=color:#f92672>-</span>x86<span style=color:#f92672>-</span><span style=color:#ae81ff>64.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span><span style=color:#ae81ff>13</span>,<span style=color:#ae81ff>781</span> ( <span style=color:#ae81ff>5.60</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>tunables<span style=color:#f92672>.</span>c:__GI___tunables_init [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>ld<span style=color:#f92672>-</span>linux<span style=color:#f92672>-</span>x86<span style=color:#f92672>-</span><span style=color:#ae81ff>64.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span><span style=color:#ae81ff>13</span>,<span style=color:#ae81ff>309</span> ( <span style=color:#ae81ff>5.41</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/../</span>sysdeps<span style=color:#f92672>/</span>generic<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>new<span style=color:#f92672>-</span>hash<span style=color:#f92672>.</span>h:_dl_lookup_symbol_x
</span></span><span style=display:flex><span><span style=color:#ae81ff>11</span>,<span style=color:#ae81ff>941</span> ( <span style=color:#ae81ff>4.85</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>string<span style=color:#f92672>/../</span>sysdeps<span style=color:#f92672>/</span>x86_64<span style=color:#f92672>/</span>multiarch<span style=color:#f92672>/../</span>multiarch<span style=color:#f92672>/</span>strcmp<span style=color:#f92672>-</span>sse2<span style=color:#f92672>.</span>S:strcmp [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>ld<span style=color:#f92672>-</span>linux<span style=color:#f92672>-</span>x86<span style=color:#f92672>-</span><span style=color:#ae81ff>64.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span> <span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>951</span> ( <span style=color:#ae81ff>4.05</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>lookup<span style=color:#f92672>.</span>c:check_match [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>ld<span style=color:#f92672>-</span>linux<span style=color:#f92672>-</span>x86<span style=color:#f92672>-</span><span style=color:#ae81ff>64.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span> <span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>321</span> ( <span style=color:#ae81ff>3.38</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/</span><span style=color:#66d9ef>do</span><span style=color:#f92672>-</span>rel<span style=color:#f92672>.</span>h:_dl_relocate_object_no_relro
</span></span><span style=display:flex><span> <span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>033</span> ( <span style=color:#ae81ff>2.86</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>gzip<span style=color:#f92672>-</span><span style=color:#ae81ff>1.13</span><span style=color:#f92672>/</span>lib<span style=color:#f92672>/</span>vasnprintf<span style=color:#f92672>.</span>c:vasnprintf [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>bin<span style=color:#f92672>/</span>gzip]
</span></span><span style=display:flex><span> <span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>968</span> ( <span style=color:#ae81ff>2.83</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/../</span>sysdeps<span style=color:#f92672>/</span>x86_64<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>machine<span style=color:#f92672>.</span>h:_dl_relocate_object_no_relro
</span></span><span style=display:flex><span> <span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>935</span> ( <span style=color:#ae81ff>2.41</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/../</span>sysdeps<span style=color:#f92672>/</span>x86<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>cacheinfo<span style=color:#f92672>.</span>h:intel_check_word<span style=color:#f92672>.</span>constprop<span style=color:#f92672>.</span><span style=color:#ae81ff>0</span> [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>ld<span style=color:#f92672>-</span>linux<span style=color:#f92672>-</span>x86<span style=color:#f92672>-</span><span style=color:#ae81ff>64.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span> <span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>811</span> ( <span style=color:#ae81ff>1.96</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/../</span>bits<span style=color:#f92672>/</span>stdlib<span style=color:#f92672>-</span>bsearch<span style=color:#f92672>.</span>h:intel_check_word<span style=color:#f92672>.</span>constprop<span style=color:#f92672>.</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>402</span> ( <span style=color:#ae81ff>1.79</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>version<span style=color:#f92672>.</span>c:_dl_check_map_versions [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>ld<span style=color:#f92672>-</span>linux<span style=color:#f92672>-</span>x86<span style=color:#f92672>-</span><span style=color:#ae81ff>64.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span> <span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>356</span> ( <span style=color:#ae81ff>1.77</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>elf<span style=color:#f92672>/</span>dl<span style=color:#f92672>-</span>tunables<span style=color:#f92672>.</span>h:__GI___tunables_init
</span></span><span style=display:flex><span> <span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>348</span> ( <span style=color:#ae81ff>1.77</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>gzip<span style=color:#f92672>-</span><span style=color:#ae81ff>1.13</span><span style=color:#f92672>/</span>lib<span style=color:#f92672>/</span>printf<span style=color:#f92672>-</span>parse<span style=color:#f92672>.</span>c:vasnprintf
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>660</span> ( <span style=color:#ae81ff>1.08</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>stdio<span style=color:#f92672>-</span>common<span style=color:#f92672>/</span>vfprintf<span style=color:#f92672>-</span>internal<span style=color:#f92672>.</span>c:__printf_buffer [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>libc<span style=color:#f92672>.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>6</span>]
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>064</span> ( <span style=color:#ae81ff>0.84</span><span style=color:#f92672>%</span>)  <span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>debug<span style=color:#f92672>/</span>glibc<span style=color:#f92672>-</span><span style=color:#ae81ff>2.41</span><span style=color:#f92672>/</span>stdio<span style=color:#f92672>-</span>common<span style=color:#f92672>/</span>Xprintf_buffer_write<span style=color:#f92672>.</span>c:__printf_buffer_write [<span style=color:#f92672>/</span>usr<span style=color:#f92672>/</span>lib64<span style=color:#f92672>/</span>libc<span style=color:#f92672>.</span>so<span style=color:#f92672>.</span><span style=color:#ae81ff>6</span>]
</span></span></code></pre></div><p>While a bit verbose, it contains all the information we need. It just needs some massaging &mldr;</p><h2 id=-automate-it>ü§ñ Automate it<a hidden class=anchor aria-hidden=true href=#-automate-it>#</a></h2><p>To make our life easier, better use some glue scripting to automate the tools and parse the data with some python code to get the information we need. The complete project <a href=https://github.com/ilmanzo/binarycoverage_callgrind>is available on my GitHub repository</a>, but here an excerpt of the script <code>coverage.sh</code> that runs <code>pytest</code> and outputs coverage measure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>BINARY<span style=color:#f92672>=</span>gzip
</span></span><span style=display:flex><span>TEMP_DIR<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>mktemp -d<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>valgrind --tool<span style=color:#f92672>=</span>callgrind --trace-children<span style=color:#f92672>=</span>yes <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --callgrind-out-file<span style=color:#f92672>=</span>$TEMP_DIR/callgrind.%p pytest 2&gt; /dev/null
</span></span><span style=display:flex><span><span style=color:#75715e># dump all the functions in the binary</span>
</span></span><span style=display:flex><span>gdb -ex <span style=color:#e6db74>&#39;set pagination off&#39;</span> -ex <span style=color:#e6db74>&#39;info functions&#39;</span> -ex quit <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  <span style=color:#66d9ef>$(</span>which $BINARY<span style=color:#66d9ef>)</span> &gt; $TEMP_DIR/all_funcs.gdb
</span></span><span style=display:flex><span>python3 calc_coverage.py --binary $BINARY -d $TEMP_DIR
</span></span><span style=display:flex><span><span style=color:#75715e># Clean up: Remove the temporary directory and its contents</span>
</span></span><span style=display:flex><span>rm -rf <span style=color:#e6db74>&#34;</span>$TEMP_DIR<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&gt; ./coverage.sh
</span></span><span style=display:flex><span>============================= test session starts ==============================
</span></span><span style=display:flex><span>platform linux -- Python 3.13.2, pytest-8.3.4, pluggy-1.5.0
</span></span><span style=display:flex><span>rootdir: /home/andrea/binarycoverage
</span></span><span style=display:flex><span>collected 1 item
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_gzip.py .                                                           [100%]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>============================== 1 passed in 0.54s ===============================
</span></span><span style=display:flex><span>--- Binary coverage report ---
</span></span><span style=display:flex><span>Functions coverage: 9/80 11.25%
</span></span></code></pre></div><p>As expected, our &ldquo;smoke&rdquo; test on <code>gzip</code> runs only 9 functions of 80, with a low 11% coverage.</p><h2 id=-lets-move-forward>üèÉ‚Äç‚û°Ô∏è Let&rsquo;s move forward<a hidden class=anchor aria-hidden=true href=#-lets-move-forward>#</a></h2><p>Now we can improve our testing, as we are driven by the coverage metric. Shall we try with <code>gzip -V</code> option ?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># program should display version information</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_version</span>(capfd):
</span></span><span style=display:flex><span>    process<span style=color:#f92672>=</span>run([PROGRAM,<span style=color:#e6db74>&#39;-V&#39;</span>])
</span></span><span style=display:flex><span>    stdout, stderr <span style=color:#f92672>=</span> capfd<span style=color:#f92672>.</span>readouterr()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> process<span style=color:#f92672>.</span>returncode <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> <span style=color:#e6db74>&#34;This is free software&#34;</span> <span style=color:#f92672>in</span> stdout 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> re<span style=color:#f92672>.</span>search(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;gzip \d.\d\d&#34;</span>, stdout)
</span></span></code></pre></div><p>A simple test to ensure the program outputs a numeric version.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ./coverage.sh
</span></span><span style=display:flex><span>============================= test session starts ==============================
</span></span><span style=display:flex><span>collected 2 items
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_gzip.py ..                                                          [100%]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>============================== 2 passed in 1.17s ===============================
</span></span><span style=display:flex><span>--- Binary coverage report ---
</span></span><span style=display:flex><span>Functions coverage: 10/80 12.50%
</span></span></code></pre></div><p>A bit better! Let&rsquo;s add a negative test for good measure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># program should fail when given a non existing file</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_compress_non_existent</span>():
</span></span><span style=display:flex><span>    process<span style=color:#f92672>=</span>run([PROGRAM,<span style=color:#e6db74>&#39;foobar&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> process<span style=color:#f92672>.</span>returncode<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ./coverage.sh
</span></span><span style=display:flex><span>============================= test session starts ==============================
</span></span><span style=display:flex><span>collected 3 items
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_gzip.py ...                                                         [100%]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>============================== 3 passed in 1.51s ===============================
</span></span><span style=display:flex><span>--- Binary coverage report ---
</span></span><span style=display:flex><span>Functions coverage: 19/80 23.75%
</span></span></code></pre></div><p>We are on a good track. We doubled the coverage, and still we haven&rsquo;t compressed anything&mldr;</p><h2 id=-do-some-actual-work>üèãÔ∏è Do some actual work<a hidden class=anchor aria-hidden=true href=#-do-some-actual-work>#</a></h2><p>Time to write a test to compress and decompress a file! We introduce also an helper function in the test, as we will need it more than once:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>SAMPLE_FILE<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;sample.txt&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># program should compress and de-compress a file</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_compress_decompress</span>(capfd):
</span></span><span style=display:flex><span>    create_test_file(SAMPLE_FILE)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(SAMPLE_FILE) <span style=color:#66d9ef>as</span> file:
</span></span><span style=display:flex><span>        content<span style=color:#f92672>=</span>file<span style=color:#f92672>.</span>readlines()
</span></span><span style=display:flex><span>    process<span style=color:#f92672>=</span>run([PROGRAM,SAMPLE_FILE])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> process<span style=color:#f92672>.</span>returncode <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    compressed_file<span style=color:#f92672>=</span>SAMPLE_FILE<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;.gz&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># decompress and read back content</span>
</span></span><span style=display:flex><span>    process<span style=color:#f92672>=</span>run([PROGRAM,<span style=color:#e6db74>&#39;-d&#39;</span>,compressed_file])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> process<span style=color:#f92672>.</span>returncode <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(SAMPLE_FILE) <span style=color:#66d9ef>as</span> file:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span>(file<span style=color:#f92672>.</span>readlines()<span style=color:#f92672>==</span>content)
</span></span><span style=display:flex><span>    os<span style=color:#f92672>.</span>remove(SAMPLE_FILE)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># helper function to create a dummy sample file</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_test_file</span>(file_name):
</span></span><span style=display:flex><span>    sample_text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;This is a dummy sample text file.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    It contains some random lines of text.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    This is line 3 of the text file.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Here is line 4, just for testing purposes.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Feel free to modify or extend this text.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Open the file in write mode (&#39;w&#39;) and write the sample text to it</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(file_name, <span style=color:#e6db74>&#39;w&#39;</span>) <span style=color:#66d9ef>as</span> file:
</span></span><span style=display:flex><span>        file<span style=color:#f92672>.</span>write(sample_text)    
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&gt; ./coverage.sh
</span></span><span style=display:flex><span>============================= test session starts ==============================
</span></span><span style=display:flex><span>collected 4 items
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_gzip.py ....                                                        [100%]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>============================== 4 passed in 2.30s ===============================
</span></span><span style=display:flex><span>--- Binary coverage report ---
</span></span><span style=display:flex><span>Functions coverage: 52/80 65.00%
</span></span></code></pre></div><p>That&rsquo;s a big progress! Our tests are getting better. Just one more ? Get to the <em>evil side</em> and give it a damaged file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># program should give error on a damaged compressed file</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_decompress_error</span>(capfd):
</span></span><span style=display:flex><span>    wrong_file<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;dummy.txt&#39;</span>
</span></span><span style=display:flex><span>    create_test_file(wrong_file)
</span></span><span style=display:flex><span>    wrong_compressed<span style=color:#f92672>=</span>wrong_file<span style=color:#f92672>+</span><span style=color:#e6db74>&#39;.gz&#39;</span>
</span></span><span style=display:flex><span>    process<span style=color:#f92672>=</span>run([PROGRAM,wrong_file])
</span></span><span style=display:flex><span>    <span style=color:#75715e># now damage the compressed file by writing a random byte</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(wrong_compressed, <span style=color:#e6db74>&#34;r+b&#34;</span>) <span style=color:#66d9ef>as</span> file:
</span></span><span style=display:flex><span>        file<span style=color:#f92672>.</span>seek(<span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>        file<span style=color:#f92672>.</span>write(bytes(<span style=color:#ae81ff>0xFF</span>))
</span></span><span style=display:flex><span>    <span style=color:#75715e># decompression should fail        </span>
</span></span><span style=display:flex><span>    process<span style=color:#f92672>=</span>run([PROGRAM,<span style=color:#e6db74>&#39;-d&#39;</span>,wrong_compressed])
</span></span><span style=display:flex><span>    stdout, stderr <span style=color:#f92672>=</span> capfd<span style=color:#f92672>.</span>readouterr()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> process<span style=color:#f92672>.</span>returncode<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> <span style=color:#e6db74>&#39;invalid compressed data&#39;</span> <span style=color:#f92672>in</span> stderr
</span></span><span style=display:flex><span>    os<span style=color:#f92672>.</span>remove(wrong_file<span style=color:#f92672>+</span><span style=color:#e6db74>&#39;.gz&#39;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ./coverage.sh
</span></span><span style=display:flex><span>============================= test session starts ==============================
</span></span><span style=display:flex><span>collected 5 items
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_gzip.py .....                                                       [100%]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>============================== 5 passed in 3.02s ===============================
</span></span><span style=display:flex><span>--- Binary coverage report ---
</span></span><span style=display:flex><span>Functions coverage: 54/80 67.50%
</span></span></code></pre></div><p>That&rsquo;s some good number! Can you think of some areas of improvement ?</p><h2 id=-we-miss-something>üëì We miss something<a hidden class=anchor aria-hidden=true href=#-we-miss-something>#</a></h2><p>If you use the <code>-v</code> verbose option, the python <a href=https://github.com/ilmanzo/binarycoverage_callgrind/blob/main/calc_coverage.py><code>calc_coverage</code></a> script will output the functions which are tested and which aren&rsquo;t:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>Executed functions: atdir_eq,atdir_set,bi_windup,build_tree,compress_block,ct_tally,discard_input_bytes,do_exit,fd_safer,file_read,fill_inbuf,fill_window,finish_out,finish_up_gzip,flush_block,flush_outbuf,flush_window,gen_codes,get_input_size_and_time,get_method,get_suffix,huft_build,huft_free,inflate_codes,inflate_dynamic,init_block,input_eof,last_component,license,longest_match,main,open_and_stat,open_safer,openat_safer,pqdownheap,progerror,read_buffer,remove_output_file,rpl_fclose,rpl_fflush,rpl_fprintf,rpl_printf,rpl_vfprintf,scan_tree,send_bits,send_tree,strlwr,treat_file,unzip,updcrc,vasnprintf,write_buf,xstrdup,zip
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Missing functions : _start,abort_gzip_signal,copy,copy_block,direntry_cmp_name,display_ratio,do_list,fillbuf,fprint_off,gzip_error,inflate_fixed,make_table,mbszero,read_byte,read_error,read_pt_len,rpl_fcntl,rsync_roll,treat_stdin,try_help,unlzh,unlzw,unpack,write_error,xalloc_die,xpalloc
</span></span></code></pre></div><p>In this way, we have also some <em>hints</em> about which features of the program we aren&rsquo;t testing. In this example, among others we can cite the <code>rsync</code> compatibility and support for <code>.Z</code> files. Of course, some (like the signal handling routines) are very difficult to properly test.</p><h2 id=-final-words>üßµ Final words<a hidden class=anchor aria-hidden=true href=#-final-words>#</a></h2><p>It&rsquo;s crucial to remember that the coverage percentage obtained using this method is an approximation. <code>valgrind</code> tracks function calls, not individual line or branch executions. Therefore, a function might be called but not fully tested, leading to potential false positives. Additionally, functions indirectly exercised by other calls might not be explicitly listed, resulting in false negatives. The performance overhead introduced by <code>valgrind</code> also means this technique is more suitable for offline analysis than real-time testing.</p><p>On the other hand, it has the benefits that it&rsquo;s simple to implement, doesn&rsquo;t require big effort nor special setup and you can use it as an indication if the integration tests you are writing are improving over the time or not. Another good use can be to detect when the new version of the programs have more features, as your coverage will get lower with the update would mean you are not testing the new stuff.</p><p>Thanks for following me until the end of this long post, feel free to send comments and feedback, happy hacking! &#x1f44b;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/testing/>Testing</a></li><li><a href=https://ilmanzo.github.io/tags/tutorial/>Tutorial</a></li><li><a href=https://ilmanzo.github.io/tags/linux/>Linux</a></li><li><a href=https://ilmanzo.github.io/tags/coverage/>Coverage</a></li><li><a href=https://ilmanzo.github.io/tags/e2e/>E2e</a></li><li><a href=https://ilmanzo.github.io/tags/qa/>Qa</a></li><li><a href=https://ilmanzo.github.io/tags/tracing/>Tracing</a></li><li><a href=https://ilmanzo.github.io/tags/scripting/>Scripting</a></li></ul><nav class=paginav><a class=prev href=https://ilmanzo.github.io/post/refactoring-d-koans-with-metaprogramming/><span class=title>¬´ Prev</span><br><span>Refactoring the D Koans with metaprogramming</span>
</a><a class=next href=https://ilmanzo.github.io/post/measuring-coverage-of-integration-tests/><span class=title>Next ¬ª</span><br><span>How much code are you testing ? (1)</span></a></nav></footer></article></main><footer class=footer><span>¬© 2012-2025 Andrea Manzini</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>