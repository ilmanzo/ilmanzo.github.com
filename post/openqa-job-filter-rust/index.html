<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Writing shell filters for fun and profit | ilManzo's blog</title><meta name=keywords content="programming,Rust,shell,command line,openqa,testing"><meta name=description content="An utility to simplify monitoring openqa job clones"><meta name=author content="Andrea Manzini"><link rel=canonical href=https://ilmanzo.github.io/post/openqa-job-filter-rust/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ilmanzo.github.io/post/openqa-job-filter-rust/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL")}</script><meta property="og:url" content="https://ilmanzo.github.io/post/openqa-job-filter-rust/"><meta property="og:site_name" content="ilManzo's blog"><meta property="og:title" content="Writing shell filters for fun and profit"><meta property="og:description" content="An utility to simplify monitoring openqa job clones"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-19T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-19T00:00:00+00:00"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Shell"><meta property="article:tag" content="Command Line"><meta property="article:tag" content="Openqa"><meta property="article:tag" content="Testing"><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing shell filters for fun and profit"><meta name=twitter:description content="An utility to simplify monitoring openqa job clones"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"Writing shell filters for fun and profit","item":"https://ilmanzo.github.io/post/openqa-job-filter-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Writing shell filters for fun and profit","name":"Writing shell filters for fun and profit","description":"An utility to simplify monitoring openqa job clones","keywords":["programming","Rust","shell","command line","openqa","testing"],"articleBody":"Why ? During my daily job I have sometimes to debug failed openqa test jobs.\nOne of the testing mantra is to reproduce the issue and for that task the openqa community has developed some tooling.\nIn practice, I often have some output like this one below from some job cloning operations:\nCloning parents of sle-15-SP4-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit 1 job has been created: - sle-15-SP4-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit -\u003e https://openqa.suse.de/tests/16425390 Cloning parents of sle-15-SP5-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit 1 job has been created: - sle-15-SP5-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit -\u003e https://openqa.suse.de/tests/16425391 Cloning parents of sle-15-SP4-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit 1 job has been created: - sle-15-SP4-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit -\u003e https://openqa.suse.de/tests/16425392 And when I want to monitor those jobs, I‚Äôd need to copy-paste all the job URLs and pass them as arguments to the cool openqa-mon utility which will show and notify me of the job status in the terminal.\n$ openqa-mon https://openqa.suse.de/tests/16425390+2 Imagine having to monitor 50 openQA jobs simultaneously. Manually copying and pasting each URL from the console output into openqa-mon is time-consuming and error-prone. This quickly becomes a bottleneck in my workflow.\nInit While openQA offers a web interface for monitoring jobs, I prefer the terminal-based workflow of openqa-mon for its flexibility and scripting capabilities. However, even with openqa-mon, manually gathering the URLs remains a pain point.\nAs a lazy person, I‚Äôm always asking myself: Can I automate this? Whenever I find myself doing the same thing two or three times. Of course we can. Shall we do it in Rust ü¶Ä ? Well, why not ? Maybe I will learn something in the process üòÑ\n$ cargo init oqa-jobfilter Image credits to: @taryn-elliott\nThe complete project is available on GitHub and it‚Äôs MIT licensed.\nProblem statement The program should act as a shell filter, taking input via stdin and outputting via stdout: $ openqa-clone-job | oqa-jobfilter The program should be testable: I want to develop it using a Test-Driven development process, which allows me to change its design and inner architecture while maintaining the same behavior output should be in order and ready to be passed as an openqa-mon invocation as-is output should be as compact as possible, so for example when I have consecutive test IDs like https://openqa.suse.de/tests/1201, https://openqa.suse.de/tests/1202, https://openqa.suse.de/tests/1203, https://openqa.suse.de/tests/1204 I can simply send 1201+3 to openqa-mon . Likewise, different job IDs for the same openQA instance can be grouped with a comma separate, so when I have some cloned tests like https://openqa.suse.de/tests/1201, https://openqa.suse.de/tests/1207, https://openqa.suse.de/tests/1210, https://openqa.suse.de/tests/1215 should become openqa-mon https://openqa.suse.de 1201,1207,1210,1215 Implementation details Rust concept of Traits is essential to fullfill requisite #1 and #2. This mean we will not write a function asking for a parameter of a specific type, but we will accept any type that implements those Read/Write behavior. This is similar to interfaces from Go (or abstract classes in object oriented languages) and it‚Äôs a very powerful programming paradigm.\nSo our main will read and write from stdin/stdout, while the real computing function will just read/write from/to a ‚Äúgeneric‚Äù reader/writer. In this way we can also test the function by passing dummy inputs and inspecting outputs.\npub fn process_input\u003cR: Read, W: Write\u003e(input: R, mut output: W) -\u003e io::Result\u003c()\u003e { Requisite #3: Ordering, de-duplication, and formatting are handled by features included in the comprehensive Rust standard library.\nRequisite #4 is the trickiest: to implement the consecutive-id checking and same-domain grouping we need to store each job into a proper data structure\npub struct OpenQAJob { pub domain: Domain, pub id: u32, pub consecutive_count: u32, } which at this point deserves to be placed in a separate source file. It‚Äôs a good occasion to learn how to organize a Rust project and modelling of ‚ÄúDomain Objects‚Äù. Note that each OpenQAJob have associated functions (very similar to ‚Äúmethods‚Äù).\nSome fancy stuff I tried to make use of some Rust language feature as well:\nconstant evaluation at compile time the code is organized and split in logically separated source files the ‚Äúclippy‚Äù linter is configured as picky as possible documentation comments: we can easily extract documentation directly from the source code unit testing to cover all the cases and enable a fearless refactoring As a bonus, I added a GitHub action to run unit tests and compile the project at each commit+push; ready for a proper release cycle.\nClosing words Creating this program was a quick and dirty hacking session, so there are for sure some improvement opportunities: if you want to contribute feel free to contact me and/or file issues or pull requests. Enjoy!\n","wordCount":"732","inLanguage":"en","datePublished":"2025-01-19T00:00:00Z","dateModified":"2025-01-19T00:00:00Z","author":{"@type":"Person","name":"Andrea Manzini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/openqa-job-filter-rust/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Writing shell filters for fun and profit</h1><div class=post-description>An utility to simplify monitoring openqa job clones</div><div class=post-meta><span title='2025-01-19 00:00:00 +0000 UTC'>January 19, 2025</span>&nbsp;¬∑&nbsp;Andrea Manzini</div></header><div class=post-content><h2 id=why->Why ?<a hidden class=anchor aria-hidden=true href=#why->#</a></h2><p>During my daily job I have sometimes to debug failed <a href=https://open.qa/>openqa test jobs</a>.</p><p>One of the testing mantra is to <a href=https://www.testdevlab.com/blog/issue-reproduction-why-reproducing-bugs-matter>reproduce the issue</a> and for that task the openqa community has <a href=https://github.com/os-autoinst/scripts>developed some tooling</a>.</p><p>In practice, I often have some output like this one below from some job cloning operations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Cloning parents of sle-15-SP4-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit
</span></span><span style=display:flex><span>1 job has been created:
</span></span><span style=display:flex><span> - sle-15-SP4-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit -&gt; https://openqa.suse.de/tests/16425390
</span></span><span style=display:flex><span>Cloning parents of sle-15-SP5-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit
</span></span><span style=display:flex><span>1 job has been created:
</span></span><span style=display:flex><span> - sle-15-SP5-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit -&gt; https://openqa.suse.de/tests/16425391
</span></span><span style=display:flex><span>Cloning parents of sle-15-SP4-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit
</span></span><span style=display:flex><span>1 job has been created:
</span></span><span style=display:flex><span> - sle-15-SP4-Server-DVD-Updates-x86_64-Build20250112-1-fips_ker_mode_gnome@64bit -&gt; https://openqa.suse.de/tests/16425392
</span></span></code></pre></div><p>And when I want to monitor those jobs, I&rsquo;d need to copy-paste all the job URLs and pass them as arguments to the cool <a href=https://github.com/os-autoinst/openqa-mon>openqa-mon</a> utility which will show and notify me of the job status in the terminal.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ openqa-mon https://openqa.suse.de/tests/16425390+2
</span></span></code></pre></div><p>Imagine having to monitor 50 openQA jobs simultaneously. Manually copying and pasting each URL from the console output into openqa-mon is time-consuming and error-prone. This quickly becomes a bottleneck in my workflow.</p><h2 id=init>Init<a hidden class=anchor aria-hidden=true href=#init>#</a></h2><p>While openQA offers a web interface for monitoring jobs, I prefer the terminal-based workflow of <code>openqa-mon</code> for its flexibility and scripting capabilities. However, even with <code>openqa-mon</code>, manually gathering the URLs remains a pain point.</p><p>As a lazy person, I&rsquo;m always asking myself: Can I automate this? Whenever I find myself doing the same thing two or three times.
Of course we can. Shall we do it in Rust &#x1f980; ? Well, why not ? Maybe I will learn something in the process &#x1f604;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ cargo init oqa-jobfilter
</span></span></code></pre></div><p><img alt=crab-shell loading=lazy src=/img/pexels-taryn-elliott-6405711.jpg>
Image credits to: <a href=https://www.pexels.com/@taryn-elliott/>@taryn-elliott</a></p><p>The complete project is available on <a href=https://github.com/ilmanzo/oqa-jobfilter>GitHub</a> and it&rsquo;s MIT licensed.</p><h2 id=problem-statement>Problem statement<a hidden class=anchor aria-hidden=true href=#problem-statement>#</a></h2><ol><li>The program should act as a shell filter, taking input via stdin and outputting via stdout: <code>$ openqa-clone-job &lt;myjobs> | oqa-jobfilter</code></li><li>The program should be testable: I want to develop it using a Test-Driven development process, which allows me to change its design and inner architecture while maintaining the same behavior</li><li>output should be in order and ready to be passed as an <code>openqa-mon</code> invocation as-is</li><li>output should be as compact as possible, so for example when I have consecutive test IDs like <a href=https://openqa.suse.de/tests/1201>https://openqa.suse.de/tests/1201</a>, <a href=https://openqa.suse.de/tests/1202>https://openqa.suse.de/tests/1202</a>, <a href=https://openqa.suse.de/tests/1203>https://openqa.suse.de/tests/1203</a>, <a href=https://openqa.suse.de/tests/1204>https://openqa.suse.de/tests/1204</a> I can simply send 1201+3 to <code>openqa-mon</code> . Likewise, different job IDs for the same openQA instance can be grouped with a comma separate, so when I have some cloned tests like <a href=https://openqa.suse.de/tests/1201>https://openqa.suse.de/tests/1201</a>, <a href=https://openqa.suse.de/tests/1207>https://openqa.suse.de/tests/1207</a>, <a href=https://openqa.suse.de/tests/1210>https://openqa.suse.de/tests/1210</a>, <a href=https://openqa.suse.de/tests/1215>https://openqa.suse.de/tests/1215</a> should become</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openqa-mon https://openqa.suse.de 1201,1207,1210,1215
</span></span></code></pre></div><h2 id=implementation-details>Implementation details<a hidden class=anchor aria-hidden=true href=#implementation-details>#</a></h2><p>Rust concept of <a href=https://doc.rust-lang.org/book/ch10-02-traits.html><code>Traits</code></a> is essential to fullfill requisite #1 and #2. This mean we will not write a function asking for a parameter of a specific type, but we will accept <strong>any</strong> type that implements those Read/Write behavior. This is similar to <a href=https://go.dev/tour/methods/9>interfaces</a> from Go (or abstract classes in object oriented languages) and it&rsquo;s a very powerful programming paradigm.</p><p>So our main will read and write from stdin/stdout, while the real computing function will just read/write from/to a &ldquo;generic&rdquo; reader/writer. In this way we can also test the function by passing dummy inputs and inspecting outputs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process_input</span><span style=color:#f92672>&lt;</span>R: <span style=color:#a6e22e>Read</span>, W: <span style=color:#a6e22e>Write</span><span style=color:#f92672>&gt;</span>(input: <span style=color:#a6e22e>R</span>, <span style=color:#66d9ef>mut</span> output: <span style=color:#a6e22e>W</span>) -&gt; <span style=color:#a6e22e>io</span>::Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span></code></pre></div><p>Requisite #3: Ordering, <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html#method.dedup>de-duplication</a>, and formatting are handled by features included in the comprehensive Rust standard library.</p><p>Requisite #4 is the trickiest: to implement the consecutive-id checking and same-domain grouping we need to store each job into a proper data structure</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OpenQAJob</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> domain: <span style=color:#a6e22e>Domain</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> id: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> consecutive_count: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>which at this point deserves to be placed in a separate source file. It&rsquo;s a good occasion to learn how to organize a Rust project and modelling of &ldquo;Domain Objects&rdquo;. Note that each <code>OpenQAJob</code> have associated functions (very similar to &ldquo;methods&rdquo;).</p><h2 id=some-fancy-stuff>Some fancy stuff<a hidden class=anchor aria-hidden=true href=#some-fancy-stuff>#</a></h2><ul><li><p>I tried to make use of some Rust language feature as well:</p><ul><li><a href=https://doc.rust-lang.org/reference/const_eval.html>constant evaluation at compile time</a></li><li>the code is organized and split in logically separated source files</li><li>the <a href=https://github.com/rust-lang/rust-clippy>&ldquo;clippy&rdquo; linter</a> is configured as picky as possible</li><li>documentation comments: we can easily extract documentation directly from the source code</li><li>unit testing to cover all the cases and enable a fearless refactoring</li></ul></li><li><p>As a bonus, I added a GitHub action to run unit tests and compile the project at each commit+push; ready for a proper release cycle.</p></li></ul><h2 id=closing-words>Closing words<a hidden class=anchor aria-hidden=true href=#closing-words>#</a></h2><p>Creating this program was a quick and dirty hacking session, so there are for sure some improvement opportunities: if you want to contribute feel free to contact me and/or file issues or pull requests. Enjoy!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/programming/>Programming</a></li><li><a href=https://ilmanzo.github.io/tags/rust/>Rust</a></li><li><a href=https://ilmanzo.github.io/tags/shell/>Shell</a></li><li><a href=https://ilmanzo.github.io/tags/command-line/>Command Line</a></li><li><a href=https://ilmanzo.github.io/tags/openqa/>Openqa</a></li><li><a href=https://ilmanzo.github.io/tags/testing/>Testing</a></li></ul><nav class=paginav><a class=prev href=https://ilmanzo.github.io/post/systemd-socket-activated-services/><span class=title>¬´ Prev</span><br><span>Systemd Socket Activation Explained</span>
</a><a class=next href=https://ilmanzo.github.io/post/advent_of_code_2024/><span class=title>Next ¬ª</span><br><span>Debriefing Advent of Code 2024</span></a></nav></footer></article></main><footer class=footer><span>¬© 2012-2025 Andrea Manzini</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>