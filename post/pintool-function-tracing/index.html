<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How much code are you testing ? (3) | ilManzo's blog</title><meta name=keywords content="testing,tutorial,linux,coverage,e2e,qa,tracing,scripting,C,C++,instrumentation"><meta name=description content="Using Intel PIN to measure test coverage on binaries"><meta name=author content="Andrea Manzini"><link rel=canonical href=https://ilmanzo.github.io/post/pintool-function-tracing/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ilmanzo.github.io/post/pintool-function-tracing/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL")}</script><meta property="og:url" content="https://ilmanzo.github.io/post/pintool-function-tracing/"><meta property="og:site_name" content="ilManzo's blog"><meta property="og:title" content="How much code are you testing ? (3)"><meta property="og:description" content="Using Intel PIN to measure test coverage on binaries"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-06-17T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-17T00:00:00+00:00"><meta property="article:tag" content="Testing"><meta property="article:tag" content="Tutorial"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Coverage"><meta property="article:tag" content="E2e"><meta property="article:tag" content="Qa"><meta name=twitter:card content="summary"><meta name=twitter:title content="How much code are you testing ? (3)"><meta name=twitter:description content="Using Intel PIN to measure test coverage on binaries"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"How much code are you testing ? (3)","item":"https://ilmanzo.github.io/post/pintool-function-tracing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How much code are you testing ? (3)","name":"How much code are you testing ? (3)","description":"Using Intel PIN to measure test coverage on binaries","keywords":["testing","tutorial","linux","coverage","e2e","qa","tracing","scripting","C","C++","instrumentation"],"articleBody":"‚ñ∂Ô∏è Intro : Let Me Be On the previous post we continued our journey with a more complex scenario, using a mix of gdb and valgrind to trace all the function execution inside a given binary.\nThis time, hold on because we‚Äôre cranking up the complexity. We‚Äôll dive deeper into low-level analysis and explore how to use Intel PIN, a powerful dynamic instrumentation framework for manipulating and inspecting executable code at runtime.\n(Photo by FURQAN KHURSHID)\nLet‚Äôs start with a basic C program, that changes behavior depending on command line arguments:\nüéØ The target: Gonna Make You Sweat #include #include int add(int a, int b) { return a+b; } int mul(int a, int b) { return a*b; } int main(int argc, char **argv) { if (argc \u003c 3) { // must input 2 number args fprintf(stderr, \"input 2 numbers for calc add or mul.\\n\"); fprintf(stderr, \"Usage) ./a.out 1 2\\n\"); return -1; } int a = atoi(argv[1]); int b = atoi(argv[2]); if (a \u003c b) { printf(\"the answer is a + b = %d\\n\", add(a, b)); } else { printf(\"the answer is a * b = %d\\n\", mul(a, b)); } return 0; } Then we compile it and it will be our test bed\n$ cc -g -gdwarf-4 main.c -o cov_sample $ example/cov_sample 7 3 the answer is a * b = 21 $ example/cov_sample 2 5 the answer is a + b = 7 We‚Äôre compiling with the -g flag to embed debug information directly into the executable. While this isn‚Äôt strictly required - Pin can also work with external debug symbol files - it simplifies our example.\nüìå A tracing tool: Surrender Intel PIN is a dynamic binary instrumentation framework for the the IA-32 and x86-64 instruction-set architectures that enables the creation of dynamic program analysis tools. Pin is provided and supported by Intel, free of charge for any type of use, under the terms of the Intel Simplified Software License (ISSL). All source code contained in the Pin kit, including scripts, sample code and headers, is governed by the MIT license.\nPin allows a tool to insert arbitrary code (written in C or C++) in arbitrary places in the executable. The code is added dynamically while the executable is running. This also makes it possible to attach Pin to an already running process.\nPin provides a rich API that abstracts away the underlying instruction set idiosyncracies and allows context information such as register contents to be passed to the injected code as parameters. Pin automatically saves and restores the registers that are overwritten by the injected code so the application continues to work. Limited access to symbol and debug information is available as well.\nWithout further ado, let‚Äôs see how a pintool looks like:\n/* FuncTracer.cpp */ #include \"pin.H\" #include // This function is called before every function in the instrumented application. // It logs the process ID, image name, and function name. VOID log_function_call(const char *img_name, const char *func_name) { // ... } // Pin calls this function for every image loaded into the process's address space. // An image is either an executable or a shared library. VOID ImageLoad(IMG img, VOID *v) { // We iterate through all the routines (functions) in the image. for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)) { for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn)) { std::stringstream ss; RTN_Open(rtn); ss \u003c\u003c \"[Image:\" \u003c\u003c IMG_Name(img) \u003c\u003c \"] [Function:\" \u003c\u003c RTN_Name(rtn) \u003c\u003c \"]\\n\" ; LOG(ss.str()); // For each routine, we insert a call to our analysis function `log_function_call`. RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)log_function_call, IARG_PTR, IMG_Name(img).c_str(), IARG_PTR, RTN_Name(rtn).c_str(), IARG_END); RTN_Close(rtn); } } } int main(int argc, char *argv[]) { PIN_InitSymbols(); if (PIN_Init(argc, argv)) { std::cerr \u003c\u003c \"PIN_Init failed\" \u003c\u003c std::endl; return 1; } // Register the function to be called for every loaded image. IMG_AddInstrumentFunction(ImageLoad, 0); PIN_StartProgram(); return 0; } (this is a stripped down version, the complete program is available on my repository). Many thanks to @simotin13 for providing a valuable starting point!\nWe need to compile this program in a shared .so library, following the documentation ; if you are lazy or eager, you will find an handy build.sh script and Makefiles to properly compile and link everything.\nüíå What is logged ? Now we can run pin, passing it our plugin, and execute the target, which will be injected with our instrumentation code.\nexport PIN_ROOT = $PIN_ROOT/pin -t ./obj-intel64/FuncTracer.so -- example/cov_sample 7 3 This command runs our target binary under Pin‚Äôs control, using our new custom probe. It creates a log file (pintool.log) with a detailed trace. Let‚Äôs look at a snippet of the output:\nPin: pin-3.31-98869-fa6f126a8 Copyright 2002-2024 Intel Corporation. [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:_init] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:.plt] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:printf@plt] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:atoi@plt] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:fwrite@plt] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:_start] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:_dl_relocate_static_pie] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:deregister_tm_clones] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:register_tm_clones] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:__do_global_dtors_aux] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:frame_dummy] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:main] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:add] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:mul] [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:_fini] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_call_libc_early_init.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:remove_slotinfo.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_close_worker.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_map_object_deps.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_fini.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:call_init.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_notify_new_object.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:add_name_to_object.isra.0.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:expand_dynamic_string_token.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_init_paths.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_map_object_from_fd.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_map_object.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_lookup_symbol_x.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:__minimal_realloc.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_new_object.cold] [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:add_to_global_update.cold] ... [tid:10367] [PID:10367] [Image:/lib64/libc.so.6] [Called:pthread_mutex_unlock] [tid:10367] [PID:10367] [Image:/lib64/libc.so.6] [Called:__GI___pthread_mutex_unlock_usercnt] [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_call_fini] [tid:10367] [PID:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Called:__do_global_dtors_aux] [tid:10367] [PID:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Called:deregister_tm_clones] [tid:10367] [PID:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Called:_fini] [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_audit_objclose] [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_call_fini] [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_audit_objclose] [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_call_fini] [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_audit_objclose] [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_audit_activity_nsid] Since the log contains both the list of all functions of our binary, and the functions that has been executed, it‚Äôs easy to cook up a script that emits a fancy coverage report.\n================================================== Image: /home/andrea/CodeCoverage/example/cov_sample ================================================== Functions Found: 15 Functions Called: 12 Coverage: 80.00% -------------------------------------------------- Called Functions: - .plt - __do_global_dtors_aux - _fini - _init - _start - atoi@plt - deregister_tm_clones - frame_dummy - main - add - printf@plt - register_tm_clones Uncalled Functions: - _dl_relocate_static_pie - mul - fwrite@plt and with some markup:\nnow we also have an hint of where is better to focus our testing, because some of the program functions have not been called.\nAs an improvement, we could prepare a ‚Äúwhitelist‚Äù of functions that are intrinsic to the execution environment (like main, _start and so on) that can be excluded from the report.\nü™© Going further On the repository you can find some bonus content:\na Python program that analyzes the log and outputs the coverage reports a convenient wrap.sh utility that takes a binary, replaces it with the proper instrumentation call, and then optionally restore the previous state. Next step: instead of a dummy target, we‚Äôll ‚Äúmeasure‚Äù operating system binaries, with full automation and without the need of recompilation. Never give (U) up üôÇ‚Äç‚ÜîÔ∏è\np.s. If you didn‚Äôt notice: as a summer easter egg, every section of this post is an Eurodance 90 song üéß Enjoy!\n","wordCount":"1152","inLanguage":"en","datePublished":"2025-06-17T00:00:00Z","dateModified":"2025-06-17T00:00:00Z","author":{"@type":"Person","name":"Andrea Manzini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/pintool-function-tracing/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">How much code are you testing ? (3)</h1><div class=post-description>Using Intel PIN to measure test coverage on binaries</div><div class=post-meta><span title='2025-06-17 00:00:00 +0000 UTC'>June 17, 2025</span>&nbsp;¬∑&nbsp;<span>Andrea Manzini</span></div></header><div class=post-content><h2 id=-intro--let-me-be>‚ñ∂Ô∏è Intro : <a href="https://www.youtube.com/watch?v=mjPVv5ojKTo">Let Me Be</a><a hidden class=anchor aria-hidden=true href=#-intro--let-me-be>#</a></h2><p>On the <a href=https://ilmanzo.github.io/post/measuring-test-coverage-on-binaries/>previous post</a> we continued our journey with a more complex scenario, using a mix of <code>gdb</code> and <code>valgrind</code> to trace all the function execution inside a given binary.</p><p>This time, hold on because we&rsquo;re cranking up the complexity. We&rsquo;ll dive deeper into low-level analysis and explore how to use <a href=https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html>Intel PIN</a>, a powerful dynamic instrumentation framework for manipulating and inspecting executable code at runtime.</p><p><img alt=probe loading=lazy src=/img/pexels-furqan-khurshid-484332193-25655714.jpg>
(Photo by <a href=https://www.pexels.com/photo/close-up-of-a-man-soldering-25655714/>FURQAN KHURSHID</a>)</p><p>Let&rsquo;s start with a basic C program, that changes behavior depending on command line arguments:</p><h2 id=-the-target-gonna-make-you-sweat>üéØ The target: <a href="https://www.youtube.com/watch?v=LaTGrV58wec">Gonna Make You Sweat</a><a hidden class=anchor aria-hidden=true href=#-the-target-gonna-make-you-sweat>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) { <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mul</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) { <span style=color:#66d9ef>return</span> a<span style=color:#f92672>*</span>b; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// must input 2 number args
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;input 2 numbers for calc add or mul.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Usage) ./a.out 1 2</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&lt;</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;the answer is a + b = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>add</span>(a, b));
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span>  {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;the answer is a * b = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>mul</span>(a, b));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Then we compile it and it will be our test bed</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cc -g -gdwarf-4 main.c -o cov_sample
</span></span><span style=display:flex><span>$ example/cov_sample <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>the answer is a * b <span style=color:#f92672>=</span> <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>$ example/cov_sample <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>the answer is a + b <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span></span></span></code></pre></div><p>We&rsquo;re compiling with the <code>-g</code> flag to embed debug information directly into the executable. While this isn&rsquo;t strictly required - Pin can also work with external debug symbol files - it simplifies our example.</p><h2 id=-a-tracing-tool-surrender>üìå A tracing tool: <a href="https://www.youtube.com/watch?v=Uj_oZ48ccPc">Surrender</a><a hidden class=anchor aria-hidden=true href=#-a-tracing-tool-surrender>#</a></h2><p><a href=https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html>Intel PIN</a> is a dynamic binary instrumentation framework for the the IA-32 and x86-64 instruction-set architectures that enables the creation of dynamic program analysis tools. Pin is provided and supported by Intel, free of charge for any type of use, under the terms of the Intel Simplified Software License (<a href=https://software.intel.com/sites/landingpage/pintool/intel-simplified-software-license.txt>ISSL</a>).
All source code contained in the Pin kit, including scripts, sample code and headers, is governed by the <a href=https://software.intel.com/sites/landingpage/pintool/LICENSE-mit.txt>MIT license</a>.</p><p>Pin allows a tool to insert arbitrary code (written in C or C++) in arbitrary places in the executable. The code is added dynamically while the executable is running. This also makes it possible to attach Pin to an already running process.</p><p>Pin provides a rich API that abstracts away the underlying instruction set idiosyncracies and allows context information such as register contents to be passed to the injected code as parameters. Pin automatically saves and restores the registers that are overwritten by the injected code so the application continues to work. Limited access to symbol and debug information is available as well.</p><p>Without further ado, let&rsquo;s see how a <code>pintool</code> looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* FuncTracer.cpp */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;pin.H&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This function is called before every function in the instrumented application.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// It logs the process ID, image name, and function name.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>VOID <span style=color:#a6e22e>log_function_call</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>img_name, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>func_name)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Pin calls this function for every image loaded into the process&#39;s address space.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// An image is either an executable or a shared library.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>VOID <span style=color:#a6e22e>ImageLoad</span>(IMG img, VOID <span style=color:#f92672>*</span>v)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We iterate through all the routines (functions) in the image.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (SEC sec <span style=color:#f92672>=</span> IMG_SecHead(img); SEC_Valid(sec); sec <span style=color:#f92672>=</span> SEC_Next(sec))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (RTN rtn <span style=color:#f92672>=</span> SEC_RtnHead(sec); RTN_Valid(rtn); rtn <span style=color:#f92672>=</span> RTN_Next(rtn))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>stringstream ss;
</span></span><span style=display:flex><span>            RTN_Open(rtn);
</span></span><span style=display:flex><span>            ss <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Image:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> IMG_Name(img) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;] [Function:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> RTN_Name(rtn) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> ;
</span></span><span style=display:flex><span>            LOG(ss.str());
</span></span><span style=display:flex><span>            <span style=color:#75715e>// For each routine, we insert a call to our analysis function `log_function_call`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)log_function_call,
</span></span><span style=display:flex><span>                           IARG_PTR, IMG_Name(img).c_str(),
</span></span><span style=display:flex><span>                           IARG_PTR, RTN_Name(rtn).c_str(),
</span></span><span style=display:flex><span>                           IARG_END);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            RTN_Close(rtn);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PIN_InitSymbols();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (PIN_Init(argc, argv))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;PIN_Init failed&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Register the function to be called for every loaded image.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    IMG_AddInstrumentFunction(ImageLoad, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    PIN_StartProgram();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>(this is a stripped down version, the complete program is available <a href=https://github.com/ilmanzo/BinaryCoverage>on my repository</a>). Many thanks to <a href=https://github.com/simotin13>@simotin13</a> for providing a valuable starting point!</p><p>We need to compile this program in a shared <code>.so</code> library, following the <a href=https://software.intel.com/sites/landingpage/pintool/docs/98869/Pin/doc/html/index.html#BUILDINGTOOLS>documentation</a> ; if you are lazy or eager, you will find an handy <a href=https://github.com/ilmanzo/BinaryCoverage><code>build.sh</code></a> script and <em>Makefiles</em> to properly compile and link everything.</p><h2 id=-what-is-logged->üíå <a href="https://www.youtube.com/watch?v=HEXWRTEbj1I">What is logged ?</a><a hidden class=anchor aria-hidden=true href=#-what-is-logged->#</a></h2><p>Now we can run pin, passing it our plugin, and execute the target, which will be injected with our instrumentation code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export PIN_ROOT <span style=color:#f92672>=</span> &lt;your PIN install directory&gt;
</span></span><span style=display:flex><span>$PIN_ROOT/pin -t ./obj-intel64/FuncTracer.so -- example/cov_sample <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>3</span></span></span></code></pre></div><p>This command runs our target binary under Pin&rsquo;s control, using our new custom probe. It creates a log file (pintool.log) with a detailed trace. Let&rsquo;s look at a snippet of the output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Pin: pin-3.31-98869-fa6f126a8
</span></span><span style=display:flex><span>Copyright 2002-2024 Intel Corporation.
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:_init]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:.plt]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:printf@plt]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:atoi@plt]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:fwrite@plt]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:_start]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:_dl_relocate_static_pie]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:deregister_tm_clones]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:register_tm_clones]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:__do_global_dtors_aux]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:frame_dummy]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:main]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:add]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:mul]
</span></span><span style=display:flex><span> [tid:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Function:_fini]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_call_libc_early_init.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:remove_slotinfo.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_close_worker.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_map_object_deps.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_fini.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:call_init.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_notify_new_object.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:add_name_to_object.isra.0.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:expand_dynamic_string_token.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_init_paths.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_map_object_from_fd.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_map_object.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_lookup_symbol_x.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:__minimal_realloc.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:_dl_new_object.cold]
</span></span><span style=display:flex><span> [tid:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Function:add_to_global_update.cold]
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/libc.so.6] [Called:pthread_mutex_unlock]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/libc.so.6] [Called:__GI___pthread_mutex_unlock_usercnt]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_call_fini]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Called:__do_global_dtors_aux]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Called:deregister_tm_clones]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/home/andrea/CodeCoverage/example/cov_sample] [Called:_fini]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_audit_objclose]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_call_fini]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_audit_objclose]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_call_fini]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_audit_objclose]
</span></span><span style=display:flex><span> [tid:10367] [PID:10367] [Image:/lib64/ld-linux-x86-64.so.2] [Called:_dl_audit_activity_nsid]
</span></span></code></pre></div><p>Since the log contains both the list of all functions of our binary, and the functions that has been executed, it&rsquo;s easy to cook up a script that emits a fancy coverage report.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>==================================================
</span></span><span style=display:flex><span>Image: /home/andrea/CodeCoverage/example/cov_sample
</span></span><span style=display:flex><span>==================================================
</span></span><span style=display:flex><span>  Functions Found:   15
</span></span><span style=display:flex><span>  Functions Called:  12
</span></span><span style=display:flex><span>  Coverage:          80.00%
</span></span><span style=display:flex><span>--------------------------------------------------
</span></span><span style=display:flex><span>  Called Functions:
</span></span><span style=display:flex><span>    - .plt
</span></span><span style=display:flex><span>    - __do_global_dtors_aux
</span></span><span style=display:flex><span>    - _fini
</span></span><span style=display:flex><span>    - _init
</span></span><span style=display:flex><span>    - _start
</span></span><span style=display:flex><span>    - atoi@plt
</span></span><span style=display:flex><span>    - deregister_tm_clones
</span></span><span style=display:flex><span>    - frame_dummy
</span></span><span style=display:flex><span>    - main
</span></span><span style=display:flex><span>    - add
</span></span><span style=display:flex><span>    - printf@plt
</span></span><span style=display:flex><span>    - register_tm_clones
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Uncalled Functions:
</span></span><span style=display:flex><span>    - _dl_relocate_static_pie
</span></span><span style=display:flex><span>    - mul
</span></span><span style=display:flex><span>    - fwrite@plt
</span></span></code></pre></div><p>and with some markup:</p><p><img alt=report loading=lazy src=/img/pintool_coverage_report.png></p><p>now we also have an hint of where is better to focus our testing, because some of the program functions have not been called.</p><p>As an improvement, we could prepare a &ldquo;whitelist&rdquo; of functions that are <em>intrinsic</em> to the execution environment (like <code>main</code>, <code>_start</code> and so on) that can be excluded from the report.</p><h2 id=-going-further>ü™© <a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">Going further</a><a hidden class=anchor aria-hidden=true href=#-going-further>#</a></h2><p>On the <a href=https://github.com/ilmanzo/BinaryCoverage>repository</a> you can find some bonus content:</p><ul><li>a Python program that analyzes the log and outputs the coverage reports</li><li>a convenient <code>wrap.sh</code> utility that takes a binary, replaces it with the proper instrumentation call, and then optionally restore the previous state.</li></ul><p>Next step: instead of a dummy target, we&rsquo;ll &ldquo;measure&rdquo; operating system binaries, with full automation and without the need of recompilation. Never give (U) up üôÇ‚Äç‚ÜîÔ∏è</p><p>p.s.
If you didn&rsquo;t notice: as a summer easter egg, every section of this post is an Eurodance 90 song üéß Enjoy!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/testing/>Testing</a></li><li><a href=https://ilmanzo.github.io/tags/tutorial/>Tutorial</a></li><li><a href=https://ilmanzo.github.io/tags/linux/>Linux</a></li><li><a href=https://ilmanzo.github.io/tags/coverage/>Coverage</a></li><li><a href=https://ilmanzo.github.io/tags/e2e/>E2e</a></li><li><a href=https://ilmanzo.github.io/tags/qa/>Qa</a></li><li><a href=https://ilmanzo.github.io/tags/tracing/>Tracing</a></li><li><a href=https://ilmanzo.github.io/tags/scripting/>Scripting</a></li><li><a href=https://ilmanzo.github.io/tags/c/>C</a></li><li><a href=https://ilmanzo.github.io/tags/c++/>C++</a></li><li><a href=https://ilmanzo.github.io/tags/instrumentation/>Instrumentation</a></li></ul><nav class=paginav><a class=prev href=https://ilmanzo.github.io/post/june_2025_conferences/><span class=title>¬´ Prev</span><br><span>June 2025 conferences recap</span>
</a><a class=next href=https://ilmanzo.github.io/post/refactoring-d-koans-with-metaprogramming/><span class=title>Next ¬ª</span><br><span>Refactoring the D Koans with metaprogramming</span></a></nav></footer></article></main><footer class=footer><span>¬© 2012-2025 Andrea Manzini</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>