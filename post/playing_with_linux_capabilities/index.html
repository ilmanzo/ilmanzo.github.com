<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Playing with Linux kernel capabilities | ilManzo's blog</title><meta name=keywords content="linux,tutorial,system,kernel,security,sysadmin,capabilities"><meta name=description content="What are and how to use the Linux kernel capabilities"><meta name=author content="Andrea Manzini"><link rel=canonical href=https://ilmanzo.github.io/post/playing_with_linux_capabilities/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ilmanzo.github.io/post/playing_with_linux_capabilities/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL")}</script><meta property="og:url" content="https://ilmanzo.github.io/post/playing_with_linux_capabilities/"><meta property="og:site_name" content="ilManzo's blog"><meta property="og:title" content="Playing with Linux kernel capabilities"><meta property="og:description" content="What are and how to use the Linux kernel capabilities"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-08-02T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-02T00:00:00+00:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Tutorial"><meta property="article:tag" content="System"><meta property="article:tag" content="Kernel"><meta property="article:tag" content="Security"><meta property="article:tag" content="Sysadmin"><meta name=twitter:card content="summary"><meta name=twitter:title content="Playing with Linux kernel capabilities"><meta name=twitter:description content="What are and how to use the Linux kernel capabilities"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"Playing with Linux kernel capabilities","item":"https://ilmanzo.github.io/post/playing_with_linux_capabilities/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Playing with Linux kernel capabilities","name":"Playing with Linux kernel capabilities","description":"What are and how to use the Linux kernel capabilities","keywords":["linux","tutorial","system","kernel","security","sysadmin","capabilities"],"articleBody":"üîê Intro As an experienced sysadmin, you might be familiar with the traditional ‚Äúall-or-nothing‚Äù approach: if a shell or process is running with UID==0, it can do almost everything on a system; while a plain user process is restricted by some means: tipically it can‚Äôt open RAW sockets, can‚Äôt bind ‚Äúprivileged‚Äù ports under 1024, can‚Äôt change a file ownership and so on.\nLinux capabilities is a feature, gradually introduced starting from kernel 2.2, that permits a more fine-grained control over privileged operations, breaking the traditional binary root/non-root distinction. Just as by using sudo we can run specific commands as another user (even root), without permanently becoming that user, by using capabilities, we can grant a program only certain privileges without having to run it as root.\nImage credits to: @realtoughcandy\nüß© What ? The idea is simple: just split all the possible privileged kernel calls up into groups of related functionality, then we can assign processes only to the subset they need. So the kernel calls were split up into a few dozen different categories, largely successfully.\nThe Linux kernel implements a multitude of these micro-grained permissions. Some of the most common capabilities used are:\nCAP_SYS_ADMIN: Allows a wide range of operations. This capability should be avoided in favor of more specific capabilities. CAP_CHOWN: Make changes to the User ID and Group ID of files CAP_DAC_READ_SEARCH: Bypass file read, and directory read/execute checks. A program with this capability can be used to read any file on the system. CAP_DAC_OVERRIDE: Override DAC (Discretionary Access Control) i.e. bypass read/write/execute permission checks. This capability grants an executable the ability to access and modify any file on the filesystem. CAP_NET_BIND_SERVICE: Allows binding to port numbers lower than 1024. CAP_KILL: Bypass permission checks for sending signals to processes such as SIGHUP and SIGKILL. CAP_SYS_NICE: Modify the niceness value and scheduling priority of processes among others. CAP_SYS_RESOURCE: Allows overriding various limits on system resources, such as disk quotas, CPU time limits, etc. The capabilities feature was introduced in 2.2 kernel in the year 1999, but it was only scoped to processes. In 2008, capabilities were introduced for files too. At the time of writing, there are 40 capabilities defined and implements; you can get the full list with the command\n$ systemd-analyze capability or in the capabilities(7) manual page.\nüîß How ? Talking about user space, there are two different packages for capability management: libcap and libcap-ng. The latter is designed to be easier than the former, so we will focus on that one.\nLet‚Äôs install the package we will use for our experiments:\n$ sudo zypper install libpcap-ng-utils $ rpm -ql libcap-ng-utils /usr/bin/captest /usr/bin/filecap /usr/bin/netcap /usr/bin/pscap /usr/share/licenses/libcap-ng-utils /usr/share/licenses/libcap-ng-utils/COPYING /usr/share/man/man8/captest.8.gz /usr/share/man/man8/filecap.8.gz /usr/share/man/man8/netcap.8.gz /usr/share/man/man8/pscap.8.gz The package provides several useful tools:\ncaptest: Tests the capabilities of the current process filecap: Views or changes file capabilities netcap: Shows the network capabilities of network-facing programs pscap: Lists the capabilities of running processes Using filecap: filecap is used to view or change file capabilities. Here‚Äôs how to use it:\nüíª A quick example It‚Äôs easy to launch a basic http server in Python:\n/usr/bin/python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... ^C Keyboard interrupt received, exiting. by default it starts on port 8000, because unprivileged users can‚Äôt bind lower port:\n$ /usr/bin/python3 -m http.server 80 Traceback (most recent call last): [...] PermissionError: [Errno 13] Permission denied We can grant the Python binary the capability to bind to lower ports by using:\n$ sudo filecap /usr/bin/python3 net_bind_service $ /usr/bin/python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... ^C Keyboard interrupt received, exiting. to reset it back, we can use the none keyword:\n$ sudo filecap /usr/bin/python3 none $ /usr/bin/python3 -m http.server 80 [...] PermissionError: [Errno 13] Permission denied ‚öôÔ∏è Using systemd Systemd, the init system used in many modern Linux distributions, provides robust support for managing capabilities. This integration allows for fine-grained control over service privileges without resorting to running services as root.\nCapability-related Directives: Systemd unit files support several directives for managing capabilities:\nCapabilityBoundingSet: Limits the capabilities a service can have. AmbientCapabilities: Grants additional capabilities to a service. SecureBits: Sets secure bits flags to further restrict capability usage. Here‚Äôs an example of a systemd unit service file that grants permission to bind to lower ports:\n[Service] User=bob AmbientCapabilities=CAP_NET_BIND_SERVICE üîç A look inside On Linux kernel, Conceptually capabilities are maintained in sets, which are represented as bit masks. For all running processes capability information is maintained per thread; for binaries in the file system it‚Äôs stored in extended attributes. There are five capability sets: Permitted, Inheritable, Effective, Bounding and Ambient. Of those, however, only the first three can be assigned to executable files. The Permitted capability set includes the capabilities assigned to a certain executable; the Effective set is a subset of the Permitted one and includes the capabilities which are effectively used. Finally, the Inheritable set, includes capabilities which can be inherited by child processes. For a detailed explanation of capabilities flow paths, please check this blog post from Henryk Pl√∂tz or this one from Adrian Mouat.\nFor running processes, you can easily get the bit mask looking at the /proc/$PID/status:\n$ grep Cap \"/proc/$(pidof chronyd)/status\" CapInh:\t0000000000000000 CapPrm:\t0000000002000400 CapEff:\t0000000002000400 CapBnd:\t000001c08380fddf CapAmb:\t0000000000000000 And it‚Äôs easier to read when decoded:\n$ pscap -p $(pidof chronyd) ppid pid uid command capabilities 1 1803 chrony chronyd net_bind_service, sys_time + or with the help of capsh (from package libcap-progs):\n$ capsh --decode=000001c08380fddf 0x000001c08380fddf=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_setfcap,cap_perfmon,cap_bpf,cap_checkpoint_restore üéØ Why should I care ? Capabilities offer a way to reduce a system‚Äôs attack surface by granting each service only the minimum level of privileges it needs, thus avoiding the need to run services as the root user.\nIn the era of microservices, containers and kubernetes, capabilities plays an important role for a number of reasons:\nFine-grained security control: Capabilities allow for a more granular approach to granting privileges to processes, as opposed to the traditional all-or-nothing root access. This enables containers to run with only the specific privileges they need, improving overall system security.\nPrinciple of least privilege: By assigning only necessary capabilities to containers, administrators can enforce the principle of least privilege. This reduces the potential attack surface and limits the damage that could be caused if a container is compromised.\nCompatibility with non-root containers: Many organizations prefer to run containers as non-root users for security reasons. Capabilities allow these non-root containers to perform specific privileged operations without requiring full root access.\nKubernetes Pod Security Policies: In Kubernetes, Pod Security Policies can leverage Linux capabilities to define a set of conditions that a pod must meet to be accepted into the system. This allows cluster administrators to enforce security best practices across the entire cluster. By using SecurityContext in Kubernetes manifest, you can set the capabilities in containers.\nContainer isolation: Capabilities help maintain strong isolation between containers and the host system, as well as between different containers, by limiting what each container can do.\nCompliance requirements: Many security standards and compliance frameworks require the principle of least privilege. Using capabilities helps organizations meet these requirements while still allowing containers to function as needed.\nFlexibility in container design: Developers can design containers that require specific privileged operations without needing to run the entire container as root, leading to more secure and flexible application designs.\nüîó Further Readings Docker security documentation on Linux capabilities Systemd documentation on execution environment libcap-ng project page üèÅ Outro Linux capabilities represent a powerful and flexible approach to security. By breaking down the traditional all-or-nothing root privileges into finer-grained permissions, capabilities enable system administrators and developers to implement the principle of least privilege effectively.\n","wordCount":"1268","inLanguage":"en","datePublished":"2024-08-02T00:00:00Z","dateModified":"2024-08-02T00:00:00Z","author":{"@type":"Person","name":"Andrea Manzini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/playing_with_linux_capabilities/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Playing with Linux kernel capabilities</h1><div class=post-description>What are and how to use the Linux kernel capabilities</div><div class=post-meta><span title='2024-08-02 00:00:00 +0000 UTC'>August 2, 2024</span>&nbsp;¬∑&nbsp;<span>Andrea Manzini</span></div></header><div class=post-content><h2 id=-intro>üîê Intro<a hidden class=anchor aria-hidden=true href=#-intro>#</a></h2><p>As an experienced sysadmin, you might be familiar with the traditional &ldquo;all-or-nothing&rdquo; approach: if a shell or process is running with <code>UID==0</code>, it can do almost everything on a system; while a plain user process is restricted by some means: tipically it can&rsquo;t open RAW sockets, can&rsquo;t bind &ldquo;privileged&rdquo; ports under 1024, can&rsquo;t change a file ownership and so on.</p><p>Linux capabilities is a feature, gradually introduced starting from kernel 2.2, that permits a more fine-grained control over privileged operations, breaking the traditional binary root/non-root distinction. Just as by using sudo we can run specific commands as another user (even root), without permanently becoming that user, by using capabilities, <strong>we can grant a program only certain privileges without having to run it as root</strong>.</p><p><img alt=linux-on-ice loading=lazy src=/img/pexels-realtoughcandy-11034131.jpg>
Image credits to: <a href=https://www.pexels.com/@realtoughcandy/>@realtoughcandy</a></p><h2 id=-what->üß© What ?<a hidden class=anchor aria-hidden=true href=#-what->#</a></h2><p>The idea is simple: just split all the possible privileged kernel calls up into groups of related functionality, then we can assign processes only to the subset they need. So the kernel calls were split up into a few dozen different categories, largely successfully.</p><p>The Linux kernel implements a multitude of these micro-grained permissions. Some of the most common capabilities used are:</p><ul><li>CAP_SYS_ADMIN: Allows a wide range of operations. This capability should be avoided in favor of more specific capabilities.</li><li>CAP_CHOWN: Make changes to the User ID and Group ID of files</li><li>CAP_DAC_READ_SEARCH: Bypass file read, and directory read/execute checks. A program with this capability can be used to read any file on the system.</li><li>CAP_DAC_OVERRIDE: Override DAC (Discretionary Access Control) i.e. bypass read/write/execute permission checks. This capability grants an executable the ability to access and modify any file on the filesystem.</li><li>CAP_NET_BIND_SERVICE: Allows binding to port numbers lower than 1024.</li><li>CAP_KILL: Bypass permission checks for sending signals to processes such as SIGHUP and SIGKILL.</li><li>CAP_SYS_NICE: Modify the niceness value and scheduling priority of processes among others.</li><li>CAP_SYS_RESOURCE: Allows overriding various limits on system resources, such as disk quotas, CPU time limits, etc.</li></ul><p>The capabilities feature was introduced in 2.2 kernel in the year 1999, but it was only scoped to processes. In 2008, capabilities were introduced for files too.
At the time of writing, there are 40 capabilities defined and implements; you can get the full list with the command</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ systemd-analyze capability
</span></span></code></pre></div><p>or in the <a href=https://man7.org/Linux/man-pages/man7/capabilities.7.html><code>capabilities(7)</code></a> manual page.</p><h2 id=-how->üîß How ?<a hidden class=anchor aria-hidden=true href=#-how->#</a></h2><p>Talking about user space, there are two different packages for capability management: <code>libcap</code> and <code>libcap-ng</code>. The latter is designed to be easier than the former, so we will focus on that one.</p><p>Let&rsquo;s install the package we will use for our experiments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo zypper install libpcap-ng-utils 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ rpm -ql libcap-ng-utils 
</span></span><span style=display:flex><span>/usr/bin/captest
</span></span><span style=display:flex><span>/usr/bin/filecap
</span></span><span style=display:flex><span>/usr/bin/netcap
</span></span><span style=display:flex><span>/usr/bin/pscap
</span></span><span style=display:flex><span>/usr/share/licenses/libcap-ng-utils
</span></span><span style=display:flex><span>/usr/share/licenses/libcap-ng-utils/COPYING
</span></span><span style=display:flex><span>/usr/share/man/man8/captest.8.gz
</span></span><span style=display:flex><span>/usr/share/man/man8/filecap.8.gz
</span></span><span style=display:flex><span>/usr/share/man/man8/netcap.8.gz
</span></span><span style=display:flex><span>/usr/share/man/man8/pscap.8.gz
</span></span></code></pre></div><p>The package provides several useful tools:</p><ul><li><code>captest</code>: Tests the capabilities of the current process</li><li><code>filecap</code>: Views or changes file capabilities</li><li><code>netcap</code>: Shows the network capabilities of network-facing programs</li><li><code>pscap</code>: Lists the capabilities of running processes</li></ul><p>Using filecap:
<code>filecap</code> is used to view or change file capabilities. Here&rsquo;s how to use it:</p><h2 id=-a-quick-example>üíª A quick example<a hidden class=anchor aria-hidden=true href=#-a-quick-example>#</a></h2><p>It&rsquo;s easy to launch a basic http server in Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/usr/bin/python3 -m http.server   
</span></span><span style=display:flex><span>Serving HTTP on 0.0.0.0 port <span style=color:#ae81ff>8000</span> <span style=color:#f92672>(</span>http://0.0.0.0:8000/<span style=color:#f92672>)</span> ...
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>Keyboard interrupt received, exiting.
</span></span></code></pre></div><p>by default it starts on port 8000, because unprivileged users can&rsquo;t bind lower port:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ /usr/bin/python3 -m http.server <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>Traceback <span style=color:#f92672>(</span>most recent call last<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>PermissionError: <span style=color:#f92672>[</span>Errno 13<span style=color:#f92672>]</span> Permission denied
</span></span></code></pre></div><p>We can grant the Python binary the capability to bind to lower ports by using:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo filecap /usr/bin/python3 net_bind_service
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ /usr/bin/python3 -m http.server <span style=color:#ae81ff>80</span>               
</span></span><span style=display:flex><span>Serving HTTP on 0.0.0.0 port <span style=color:#ae81ff>80</span> <span style=color:#f92672>(</span>http://0.0.0.0:80/<span style=color:#f92672>)</span> ...
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>Keyboard interrupt received, exiting.
</span></span></code></pre></div><p>to reset it back, we can use the <code>none</code> keyword:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo filecap /usr/bin/python3 none
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ /usr/bin/python3 -m http.server <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>          
</span></span><span style=display:flex><span>PermissionError: <span style=color:#f92672>[</span>Errno 13<span style=color:#f92672>]</span> Permission denied
</span></span></code></pre></div><h2 id=-using-systemd>‚öôÔ∏è Using systemd<a hidden class=anchor aria-hidden=true href=#-using-systemd>#</a></h2><p>Systemd, the init system used in many modern Linux distributions, provides robust support for managing capabilities.
This integration allows for fine-grained control over service privileges without resorting to running services as root.</p><p>Capability-related Directives:
Systemd unit files support several directives for managing capabilities:</p><ul><li><code>CapabilityBoundingSet</code>: Limits the capabilities a service can have.</li><li><code>AmbientCapabilities</code>: Grants additional capabilities to a service.</li><li><code>SecureBits</code>: Sets secure bits flags to further restrict capability usage.</li></ul><p>Here&rsquo;s an example of a systemd unit service file that grants permission to bind to lower ports:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>[Service]
</span></span><span style=display:flex><span>User=bob
</span></span><span style=display:flex><span>AmbientCapabilities=CAP_NET_BIND_SERVICE
</span></span></code></pre></div><h2 id=-a-look-inside>üîç A look inside<a hidden class=anchor aria-hidden=true href=#-a-look-inside>#</a></h2><p>On Linux kernel, Conceptually capabilities are maintained in sets, which are represented as bit masks. For all running processes capability information is maintained per thread; for binaries in the file system it‚Äôs stored in extended attributes.
There are five capability sets: <em>Permitted</em>, <em>Inheritable</em>, <em>Effective</em>, <em>Bounding</em> and <em>Ambient</em>. Of those, however, only the first three can be assigned to executable files. The <em>Permitted</em> capability set includes the capabilities assigned to a certain executable; the <em>Effective</em> set is a subset of the Permitted one and includes the capabilities which are effectively used. Finally, the <em>Inheritable</em> set, includes capabilities which can be inherited by child processes. For a detailed explanation of capabilities flow paths, please check <a href=https://blog.ploetzli.ch/2014/understanding-Linux-capabilities/>this blog post</a> from Henryk Pl√∂tz or <a href=https://blog.container-solutions.com/Linux-capabilities-why-they-exist-and-how-they-work>this one</a> from Adrian Mouat.</p><p>For running processes, you can easily get the bit mask looking at the <code>/proc/$PID/status</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ grep Cap <span style=color:#e6db74>&#34;/proc/</span><span style=color:#66d9ef>$(</span>pidof chronyd<span style=color:#66d9ef>)</span><span style=color:#e6db74>/status&#34;</span>
</span></span><span style=display:flex><span>CapInh:	<span style=color:#ae81ff>0000000000000000</span>
</span></span><span style=display:flex><span>CapPrm:	<span style=color:#ae81ff>0000000002000400</span>
</span></span><span style=display:flex><span>CapEff:	<span style=color:#ae81ff>0000000002000400</span>
</span></span><span style=display:flex><span>CapBnd:	000001c08380fddf
</span></span><span style=display:flex><span>CapAmb:	<span style=color:#ae81ff>0000000000000000</span>
</span></span></code></pre></div><p>And it&rsquo;s easier to read when decoded:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ pscap -p <span style=color:#66d9ef>$(</span>pidof chronyd<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>ppid  pid   uid         command             capabilities
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>     <span style=color:#ae81ff>1803</span>  chrony      chronyd             net_bind_service, sys_time +
</span></span></code></pre></div><p>or with the help of <code>capsh</code> (from package <code>libcap-progs</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ capsh --decode<span style=color:#f92672>=</span>000001c08380fddf 
</span></span><span style=display:flex><span>0x000001c08380fddf<span style=color:#f92672>=</span>cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_setfcap,cap_perfmon,cap_bpf,cap_checkpoint_restore
</span></span></code></pre></div><h2 id=-why-should-i-care->üéØ Why should I care ?<a hidden class=anchor aria-hidden=true href=#-why-should-i-care->#</a></h2><p>Capabilities offer a way to reduce a system&rsquo;s attack surface by granting each service only the minimum level of privileges it needs, thus avoiding the need to run services as the root user.</p><p>In the era of microservices, containers and kubernetes, capabilities plays an important role for a number of reasons:</p><ul><li><p><em>Fine-grained security control</em>:
Capabilities allow for a more granular approach to granting privileges to processes, as opposed to the traditional all-or-nothing root access. This enables containers to run with only the specific privileges they need, improving overall system security.</p></li><li><p><em>Principle of least privilege</em>:
By assigning only necessary capabilities to containers, administrators can enforce the principle of least privilege. This reduces the potential attack surface and limits the damage that could be caused if a container is compromised.</p></li><li><p><em>Compatibility with non-root containers</em>:
Many organizations prefer to run containers as non-root users for security reasons. Capabilities allow these non-root containers to perform specific privileged operations without requiring full root access.</p></li><li><p><em>Kubernetes Pod Security Policies</em>:
In Kubernetes, Pod Security Policies can leverage Linux capabilities to define a set of conditions that a pod must meet to be accepted into the system. This allows cluster administrators to enforce security best practices across the entire cluster. By using <code>SecurityContext</code> in Kubernetes manifest, you can set the capabilities in containers.</p></li><li><p><em>Container isolation</em>:
Capabilities help maintain strong isolation between containers and the host system, as well as between different containers, by limiting what each container can do.</p></li><li><p><em>Compliance requirements</em>:
Many security standards and compliance frameworks require the principle of least privilege. Using capabilities helps organizations meet these requirements while still allowing containers to function as needed.</p></li><li><p><em>Flexibility in container design</em>:
Developers can design containers that require specific privileged operations without needing to run the entire container as root, leading to more secure and flexible application designs.</p></li></ul><h2 id=-further-readings>üîó Further Readings<a hidden class=anchor aria-hidden=true href=#-further-readings>#</a></h2><ul><li><a href=https://docs.docker.com/engine/security/security/#linux-kernel-capabilities>Docker security documentation on Linux capabilities</a></li><li><a href=https://www.freedesktop.org/software/systemd/man/systemd.exec.html>Systemd documentation on execution environment</a></li><li><a href=https://people.redhat.com/sgrubb/libcap-ng/>libcap-ng project page</a></li></ul><h2 id=-outro>üèÅ Outro<a hidden class=anchor aria-hidden=true href=#-outro>#</a></h2><p>Linux capabilities represent a powerful and flexible approach to security. By breaking down the traditional all-or-nothing root privileges into finer-grained permissions, capabilities enable system administrators and developers to implement the principle of least privilege effectively.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/linux/>Linux</a></li><li><a href=https://ilmanzo.github.io/tags/tutorial/>Tutorial</a></li><li><a href=https://ilmanzo.github.io/tags/system/>System</a></li><li><a href=https://ilmanzo.github.io/tags/kernel/>Kernel</a></li><li><a href=https://ilmanzo.github.io/tags/security/>Security</a></li><li><a href=https://ilmanzo.github.io/tags/sysadmin/>Sysadmin</a></li><li><a href=https://ilmanzo.github.io/tags/capabilities/>Capabilities</a></li></ul><nav class=paginav><a class=prev href=https://ilmanzo.github.io/post/testing_a_microsd_card/><span class=title>¬´ Prev</span><br><span>Testing a cheap MicroSD card quality</span>
</a><a class=next href=https://ilmanzo.github.io/post/measure_your_power_consumption/><span class=title>Next ¬ª</span><br><span>Measure your program's power consumption</span></a></nav></footer></article></main><footer class=footer><span>¬© 2012-2025 Andrea Manzini</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>