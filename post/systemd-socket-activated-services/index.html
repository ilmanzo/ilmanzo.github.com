<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Systemd Socket Activation Explained | ilManzo's blog</title>
<meta name=keywords content="systemd,sysadmin,command line,linux,services,server,socket,learning,tutorial"><meta name=description content="Stop Wasting Resources: how to start your services on demand"><meta name=author content="Andrea Manzini"><link rel=canonical href=https://ilmanzo.github.io/post/systemd-socket-activated-services/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://ilmanzo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ilmanzo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ilmanzo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ilmanzo.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ilmanzo.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ilmanzo.github.io/post/systemd-socket-activated-services/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL")}</script><meta property="og:url" content="https://ilmanzo.github.io/post/systemd-socket-activated-services/"><meta property="og:site_name" content="ilManzo's blog"><meta property="og:title" content="Systemd Socket Activation Explained"><meta property="og:description" content="Stop Wasting Resources: how to start your services on demand"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-02-02T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-02T00:00:00+00:00"><meta property="article:tag" content="Systemd"><meta property="article:tag" content="Sysadmin"><meta property="article:tag" content="Command Line"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Services"><meta property="article:tag" content="Server"><meta name=twitter:card content="summary"><meta name=twitter:title content="Systemd Socket Activation Explained"><meta name=twitter:description content="Stop Wasting Resources: how to start your services on demand"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ilmanzo.github.io/post/"},{"@type":"ListItem","position":2,"name":"Systemd Socket Activation Explained","item":"https://ilmanzo.github.io/post/systemd-socket-activated-services/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Systemd Socket Activation Explained","name":"Systemd Socket Activation Explained","description":"Stop Wasting Resources: how to start your services on demand","keywords":["systemd","sysadmin","command line","linux","services","server","socket","learning","tutorial"],"articleBody":"ðŸ’­ What ? Imagine a web server that only starts when someone actually tries to access it. Or a database that spins up only when a query comes in: this is the magic of socket activation. The concept is not new, as old-school sysadmins may are used to see something like inetd or xinetd for on-demand service activation in the past.\nAs some cool projects like cockpit have already started using this little-known feature, in this blog post weâ€™ll see the basics and try to get familiarity with the tooling.\nðŸ”‘ Under the hood the key components are:\na .socket unit file: it defines the socket (port, protocol) to listen on. a .service unit file: it defines the service to be started upon connection. systemd associates the .socket with the .service:\nsystemd listens on the socket A client connects to the socket systemd detects the connection systemd starts the associated service systemd hands off the socket to the service The service now handles the connection directly ðŸ”¨ Letâ€™s try out Letâ€™s start with a blank slate: OpenSUSE Leap 16.0 is in Î±-testing phase so we can use it as a playfield ðŸ˜„ but at the end you can use the distro you prefer, provided it comes with the systemd service manager.\nAs a demo scenario, suppose you have built an awesome dice-as-a-serviceâ„¢ that returns you a random number each time it gets invoked. Of course itâ€™s RESTful and JSON based!\nfrom flask import Flask, jsonify import random app = Flask(__name__) @app.route('/roll') def roll_dice(): return jsonify({\"result\": random.randint(1, 6)}) (note: this is only an example, a proper production app should check inputs, handle errors, log in a proper way, and so on)\n$ sudo zypper in python3-Flask $ flask --app dice.py run \u0026 [1] 10100 andrea@toolbox-andrea-user:/tmp\u003e * Serving Flask app 'dice.py' * Debug mode: off WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on http://127.0.0.1:5000 Press CTRL+C to quit Letâ€™s test it: $ curl http://127.0.0.1:5000/roll 127.0.0.1 - - [01/Feb/2025 10:30:46] \"GET /roll HTTP/1.1\" 200 - {\"result\":2} $ curl http://127.0.0.1:5000/roll 127.0.0.1 - - [01/Feb/2025 10:30:49] \"GET /roll HTTP/1.1\" 200 - {\"result\":1} $ curl http://127.0.0.1:5000/roll 127.0.0.1 - - [01/Feb/2025 10:30:59] \"GET /roll HTTP/1.1\" 200 - {\"result\":6} $ kill %1 [1]+ Terminated flask --app dice.py run\nSeems working!\nðŸŒ¿ Donâ€™t waste resources After some frantic weeks, you discover that your service is actually used, but not as much you expected. Only some people wants to get random numbers, and only a few times per day; so it seems a bit of wasteful to have a Python interpreter always running and taking some megabytes of memory for a such small purpose. So, letâ€™s prepare a socket unit file:\n# /etc/systemd/system/diceroll.socket [Unit] Description=Socket for diceroll service activation PartOf=diceroll.service [Socket] ListenStream=5000 NoDelay=true Backlog=128 [Install] WantedBy=sockets.target and the corresponding service file:\n# /etc/systemd/system/diceroll.service [Unit] Description=Socket-activated dice rolling service Requires=diceroll.socket After=network.target [Service] ExecStart=/usr/bin/python3 /opt/dice_ng.py Type=simple Letâ€™s try it; one important note: only the .socket unit should be started and enabled at startup; the correspondind .service file will be automatically started on demand.\n$ systemctl daemon-reload $ systemctl enable --now diceroll.socket $ curl http://127.0.0.1:5000/roll curl: (56) Recv failure: Connection reset by peer Whoa, something has gone wrong ðŸ¤”\nðŸ©¹ Fixing the issue Thereâ€™s an issue in our solution: when the server spawns up, it tries to listen on the connection and it finds the socket already in use by systemd. We need to change our application to handle the socket opened and passed by systemd:\nimport socket import os, sys import flask, random from werkzeug.serving import make_server app = flask.Flask(__name__) @app.route('/roll') def roll_dice(): return {'result': random.randint(1, 6)} def get_systemd_socket(): \"\"\"Retrieve the socket passed by systemd\"\"\" listen_fds = int(os.environ.get('LISTEN_FDS', 0)) if listen_fds != 1: sys.stderr.write(\"Error: systemd did not provide exactly one socket.\\n\") sys.exit(1) sock = socket.fromfd(3, socket.AF_INET, socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) return sock if __name__ == '__main__': sock = get_systemd_socket() server = make_server('localhost', 5000, app, fd=sock.fileno()) server.serve_forever() $ curl http://127.0.0.1:5000/roll {\"result\":1} Now it works and the server starts on demand. Someone could notice that it runs forever and never stops, so after the first startup, it stays up and take some resources, even when idle! On the other hand, we cannot simply have a service that serves one connection and then immediately quit, because handling lots of connections would be less efficient and quite similar to a inetd/CGI server.\nðŸ«³ Please stop ? To solve this inconvenience, we could add some checks and logic in our application in order to quit when has been idle for too long. A similar effect can be obtained by using the --exit-idle-time option of the systemd-socket-proxyd utility, we can even use a systemd timer to gracefully kill our application after some pre-defined time. The first solution is more robust and cleaner but itâ€™s out of scope of this tutorial, maybe we will get deeper in a future article; as we want to play with systemd features for now:\n# /etc/systemd/system/diceroll.service [Unit] Description=Socket-activated dice rolling service After=network.target [Service] ExecStart=/usr/bin/python3 /opt/dice_ng.py Type=simple TimeoutStartSec=1min # Timeout after 1 minute of inactivity (no new connections) # ExecStop will be executed when the TimeoutStartSec is reached. ExecStop=/bin/systemctl stop your-app.service [Install] WantedBy=multi-user.target âŒ› How it works: The .socket file listens for connections. When a connection arrives, it activates the application service (diceroll.service). Systemd starts the application service. The TimeoutStartSec timer starts counting. If no new connections arrive within the TimeoutStartSec period, systemd considers the service start-up as failed and executes the ExecStop command, which stops the application. ðŸ‘‹ Bye Many aspects of systemd remain less widely known, and new features and capabilities are continually being added with each new version. This exploration highlights just a fraction of its potential, and further investigation into its more advanced functionalities can often unlock even more elegant and efficient solutions for service management and automation. Whether itâ€™s leveraging timers, socket activation, or exploring the intricacies of dependencies and targets, systemd offers a deep toolbox for administrators and developers alike.\n","wordCount":"997","inLanguage":"en","datePublished":"2025-02-02T00:00:00Z","dateModified":"2025-02-02T00:00:00Z","author":{"@type":"Person","name":"Andrea Manzini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ilmanzo.github.io/post/systemd-socket-activated-services/"},"publisher":{"@type":"Organization","name":"ilManzo's blog","logo":{"@type":"ImageObject","url":"https://ilmanzo.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ilmanzo.github.io/ accesskey=h title="ilManzo's blog (Alt + H)">ilManzo's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ilmanzo.github.io/curriculum title=Curriculum><span>Curriculum</span></a></li><li><a href=https://ilmanzo.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=https://ilmanzo.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://ilmanzo.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ilmanzo.github.io/post/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ilmanzo.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://ilmanzo.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Systemd Socket Activation Explained</h1><div class=post-description>Stop Wasting Resources: how to start your services on demand</div><div class=post-meta><span title='2025-02-02 00:00:00 +0000 UTC'>February 2, 2025</span>&nbsp;Â·&nbsp;Andrea Manzini</div></header><div class=post-content><h2 id=-what->ðŸ’­ What ?<a hidden class=anchor aria-hidden=true href=#-what->#</a></h2><p>Imagine a web server that only starts when someone actually tries to access it. Or a database that spins up only when a query comes in: this is the <em>magic</em> of socket activation. The concept is not new, as old-school sysadmins may are used to see something like <a href=https://en.wikipedia.org/wiki/Inetd>inetd</a> or <a href=https://en.wikipedia.org/wiki/Xinetd>xinetd</a> for on-demand service activation in the past.</p><p>As some cool projects like <a href=https://cockpit-project.org/>cockpit</a> have already started using this little-known feature, in this blog post we&rsquo;ll see the basics and try to get familiarity with the tooling.</p><h2 id=-under-the-hood>ðŸ”‘ Under the hood<a hidden class=anchor aria-hidden=true href=#-under-the-hood>#</a></h2><p>the key components are:</p><ul><li>a <code>.socket</code> unit file: it defines the socket (port, protocol) to listen on.</li><li>a <code>.service</code> unit file: it defines the service to be started upon connection.</li></ul><p>systemd associates the <code>.socket</code> with the <code>.service</code>:</p><ol><li>systemd listens on the socket</li><li>A client connects to the socket</li><li>systemd detects the connection</li><li>systemd starts the associated service</li><li>systemd hands off the socket to the service</li><li>The service now handles the connection directly</li></ol><h2 id=-lets-try-out>ðŸ”¨ Let&rsquo;s try out<a hidden class=anchor aria-hidden=true href=#-lets-try-out>#</a></h2><p>Let&rsquo;s start with a blank slate: <a href=https://get.opensuse.org/leap/16.0/>OpenSUSE Leap 16.0</a> is in Î±-testing phase so we can use it as a playfield &#x1f604; but at the end you can use the distro you prefer, provided it comes with the <a href=https://systemd.io/>systemd</a> service manager.</p><p>As a demo scenario, suppose you have built an awesome <code>dice-as-a-service</code>â„¢ that returns you a random number each time it gets invoked. Of course it&rsquo;s RESTful and JSON based!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> flask <span style=color:#f92672>import</span> Flask, jsonify
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> Flask(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/roll&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>roll_dice</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> jsonify({<span style=color:#e6db74>&#34;result&#34;</span>: random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span>)})</span></span></code></pre></div><p>(note: this is only an example, a proper production app should check inputs, handle errors, log in a proper way, and so on)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo zypper in python3-Flask
</span></span><span style=display:flex><span>$ flask --app dice.py run &amp;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>10100</span>
</span></span><span style=display:flex><span>andrea@toolbox-andrea-user:/tmp&gt;  * Serving Flask app <span style=color:#e6db74>&#39;dice.py&#39;</span>
</span></span><span style=display:flex><span> * Debug mode: off
</span></span><span style=display:flex><span>WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
</span></span><span style=display:flex><span> * Running on http://127.0.0.1:5000
</span></span><span style=display:flex><span>Press CTRL+C to quit</span></span></code></pre></div><p>Let&rsquo;s test it:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ curl http://127.0.0.1:5000/roll 
</span></span><span style=display:flex><span>127.0.0.1 - - <span style=color:#f92672>[</span>01/Feb/2025 10:30:46<span style=color:#f92672>]</span> <span style=color:#e6db74>&#34;GET /roll HTTP/1.1&#34;</span> <span style=color:#ae81ff>200</span> -
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;result&#34;</span>:2<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>$ curl http://127.0.0.1:5000/roll 
</span></span><span style=display:flex><span>127.0.0.1 - - <span style=color:#f92672>[</span>01/Feb/2025 10:30:49<span style=color:#f92672>]</span> <span style=color:#e6db74>&#34;GET /roll HTTP/1.1&#34;</span> <span style=color:#ae81ff>200</span> -
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;result&#34;</span>:1<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>$ curl http://127.0.0.1:5000/roll 
</span></span><span style=display:flex><span>127.0.0.1 - - <span style=color:#f92672>[</span>01/Feb/2025 10:30:59<span style=color:#f92672>]</span> <span style=color:#e6db74>&#34;GET /roll HTTP/1.1&#34;</span> <span style=color:#ae81ff>200</span> -
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;result&#34;</span>:6<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>$ kill %1
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>+  Terminated              flask --app dice.py run</span></span></code></pre></div></p><p>Seems working!</p><h2 id=-dont-waste-resources>ðŸŒ¿ Don&rsquo;t waste resources<a hidden class=anchor aria-hidden=true href=#-dont-waste-resources>#</a></h2><p>After some frantic weeks, you discover that your service is actually used, but not as much you expected. Only some people wants to get random numbers, and only a few times per day; so it seems a bit of wasteful to have a Python interpreter always running and taking some megabytes of memory for a such small purpose. So, let&rsquo;s prepare a <code>socket</code> unit file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># /etc/systemd/system/diceroll.socket </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Socket for diceroll service activation</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PartOf</span><span style=color:#f92672>=</span><span style=color:#e6db74>diceroll.service</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Socket]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ListenStream</span><span style=color:#f92672>=</span><span style=color:#e6db74>5000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>NoDelay</span><span style=color:#f92672>=</span><span style=color:#e6db74>true</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Backlog</span><span style=color:#f92672>=</span><span style=color:#e6db74>128</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>sockets.target</span>
</span></span></code></pre></div><p>and the corresponding <code>service</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># /etc/systemd/system/diceroll.service </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Socket-activated dice rolling service</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Requires</span><span style=color:#f92672>=</span><span style=color:#e6db74>diceroll.socket</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/bin/python3 /opt/dice_ng.py</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Type</span><span style=color:#f92672>=</span><span style=color:#e6db74>simple</span>
</span></span></code></pre></div><p>Let&rsquo;s try it; one important note: only the <code>.socket</code> unit should be started and enabled at startup; the correspondind <code>.service</code> file will be automatically started on demand.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ systemctl daemon-reload
</span></span><span style=display:flex><span>$ systemctl enable --now diceroll.socket
</span></span><span style=display:flex><span>$ curl http://127.0.0.1:5000/roll
</span></span><span style=display:flex><span>curl: <span style=color:#f92672>(</span>56<span style=color:#f92672>)</span> Recv failure: Connection reset by peer
</span></span></code></pre></div><p>Whoa, something has gone wrong &#x1f914;</p><h2 id=-fixing-the-issue>ðŸ©¹ Fixing the issue<a hidden class=anchor aria-hidden=true href=#-fixing-the-issue>#</a></h2><p>There&rsquo;s an issue in our solution: when the server spawns up, it tries to listen on the connection and it finds the socket already in use by systemd. We need to change our application to handle the socket opened and passed by systemd:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> socket
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os<span style=color:#f92672>,</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> flask<span style=color:#f92672>,</span> random
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> werkzeug.serving <span style=color:#f92672>import</span> make_server
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> flask<span style=color:#f92672>.</span>Flask(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/roll&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>roll_dice</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#e6db74>&#39;result&#39;</span>: random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span>)}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_systemd_socket</span>():
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Retrieve the socket passed by systemd&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    listen_fds <span style=color:#f92672>=</span> int(os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;LISTEN_FDS&#39;</span>, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> listen_fds <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;Error: systemd did not provide exactly one socket.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    sock <span style=color:#f92672>=</span> socket<span style=color:#f92672>.</span>fromfd(<span style=color:#ae81ff>3</span>, socket<span style=color:#f92672>.</span>AF_INET, socket<span style=color:#f92672>.</span>SOCK_STREAM)
</span></span><span style=display:flex><span>    sock<span style=color:#f92672>.</span>setsockopt(socket<span style=color:#f92672>.</span>SOL_SOCKET, socket<span style=color:#f92672>.</span>SO_REUSEADDR, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    sock <span style=color:#f92672>=</span> get_systemd_socket()
</span></span><span style=display:flex><span>    server <span style=color:#f92672>=</span> make_server(<span style=color:#e6db74>&#39;localhost&#39;</span>, <span style=color:#ae81ff>5000</span>, app, fd<span style=color:#f92672>=</span>sock<span style=color:#f92672>.</span>fileno())
</span></span><span style=display:flex><span>    server<span style=color:#f92672>.</span>serve_forever()</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ curl http://127.0.0.1:5000/roll
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;result&#34;</span>:1<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Now it works and the server starts on demand. Someone could notice that it runs forever and never stops, so after the first startup, it stays up and take some resources, even when idle!
On the other hand, we cannot simply have a service that serves one connection and then immediately quit, because handling lots of connections would be less efficient and quite similar to a inetd/CGI server.</p><h2 id=-please-stop->ðŸ«³ Please stop ?<a hidden class=anchor aria-hidden=true href=#-please-stop->#</a></h2><p>To solve this inconvenience, we could add some checks and logic in our application in order to quit when has been idle for too long. A similar effect can be obtained by using the <code>--exit-idle-time</code> option of the <a href=https://www.freedesktop.org/software/systemd/man/latest/systemd-socket-proxyd.html><code>systemd-socket-proxyd</code> utility</a>, we can even use a <a href=https://documentation.suse.com/smart/systems-management/html/systemd-working-with-timers/index.html>systemd timer</a> to gracefully kill our application after some pre-defined time. The first solution is more robust and cleaner but it&rsquo;s out of scope of this tutorial, maybe we will get deeper in a future article; as we want to play with <code>systemd</code> features for now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># /etc/systemd/system/diceroll.service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Socket-activated dice rolling service</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/bin/python3 /opt/dice_ng.py</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Type</span><span style=color:#f92672>=</span><span style=color:#e6db74>simple</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TimeoutStartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>1min  # Timeout after 1 minute of inactivity (no new connections)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ExecStop will be executed when the TimeoutStartSec is reached.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStop</span><span style=color:#f92672>=</span><span style=color:#e6db74>/bin/systemctl stop your-app.service</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><h2 id=-how-it-works>âŒ› How it works:<a hidden class=anchor aria-hidden=true href=#-how-it-works>#</a></h2><ol><li>The <code>.socket</code> file listens for connections.</li><li>When a connection arrives, it activates the application service (<code>diceroll.service</code>).</li><li>Systemd starts the application service. The <code>TimeoutStartSec</code> timer starts counting.</li><li>If no new connections arrive within the <code>TimeoutStartSec</code> period, <code>systemd</code> considers the service start-up as failed and executes the <code>ExecStop</code> command, which stops the application.</li></ol><h2 id=wave-bye>&#x1f44b; Bye<a hidden class=anchor aria-hidden=true href=#wave-bye>#</a></h2><p>Many aspects of systemd remain less widely known, and new features and capabilities are continually being added with each new version. This exploration highlights just a fraction of its potential, and further investigation into its more advanced functionalities can often unlock even more elegant and efficient solutions for service management and automation. Whether it&rsquo;s leveraging timers, socket activation, or exploring the intricacies of dependencies and targets, systemd offers a deep toolbox for administrators and developers alike.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ilmanzo.github.io/tags/systemd/>Systemd</a></li><li><a href=https://ilmanzo.github.io/tags/sysadmin/>Sysadmin</a></li><li><a href=https://ilmanzo.github.io/tags/command-line/>Command Line</a></li><li><a href=https://ilmanzo.github.io/tags/linux/>Linux</a></li><li><a href=https://ilmanzo.github.io/tags/services/>Services</a></li><li><a href=https://ilmanzo.github.io/tags/server/>Server</a></li><li><a href=https://ilmanzo.github.io/tags/socket/>Socket</a></li><li><a href=https://ilmanzo.github.io/tags/learning/>Learning</a></li><li><a href=https://ilmanzo.github.io/tags/tutorial/>Tutorial</a></li></ul><nav class=paginav><a class=prev href=https://ilmanzo.github.io/post/measuring-coverage-of-integration-tests/><span class=title>Â« Prev</span><br><span>How much code are you testing ? (1)</span>
</a><a class=next href=https://ilmanzo.github.io/post/openqa-job-filter-rust/><span class=title>Next Â»</span><br><span>Writing shell filters for fun and profit</span></a></nav></footer></article></main><footer class=footer><span>Â© 2012-2024 Andrea Manzini</span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>