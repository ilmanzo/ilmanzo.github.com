<!doctype html><html lang=en><head><title>playing with eBPF interface - 2 &ndash; ilManzo's blog</title><meta name=description content="A minimalist, pragmatic website and personal blog"><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css integrity="sha512-HK5fgLBL+xu6dm/Ii3z4xhlSUyZgTT9tuc/hSrtw6uzJOvgRr2a9jyxxT1ely+B+xFAmJKVSTbpM/CuL7qxO8w==" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin=anonymous><link rel=stylesheet href=https://ilmanzo.github.io/css/colour/gruvbox-dark.css><link rel=stylesheet href=https://ilmanzo.github.io/css/colour/dark-mode.css><link rel=stylesheet href=https://ilmanzo.github.io/css/risotto.css><link rel=stylesheet href=https://ilmanzo.github.io/css/custom.css></head><body><div class=page><header class=page__header><h1 class=page__logo><a href=https://ilmanzo.github.io/ class=page__logo-inner>ilManzo's blog</a></h1><nav class="page__nav main-nav"><ul><li class=main-nav__item><a class=nav-main-item href=/curriculum title>Curriculum</a></li><li class=main-nav__item><a class=nav-main-item href=/categories title>Categories</a></li><li class=main-nav__item><a class=nav-main-item href=/tags title>Tags</a></li><li class=main-nav__item><a class="nav-main-item active" href=/post/ title=Posts>Posts</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>playing with eBPF interface - 2</h1></header><div class=content__body><p>In the <a href=http://ilmanzo.github.io/programming/2021/05/11/playing-with-ebpf>last post</a> we introduced the <a href=https://github.com/iovisor/bcc>BCC framework</a> to interface Python code with eBPF facility. Now we are ready to make one step further!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/python3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> bcc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bpf <span style=color:#f92672>=</span> bcc<span style=color:#f92672>.</span>BPF(text<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>#include &lt;uapi/linux/ptrace.h&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>int trace_malloc(struct pt_regs *ctx, size_t size) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    bpf_trace_printk(&#34;size=</span><span style=color:#e6db74>%d</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>n&#34;,size);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    return 0;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>};&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bpf<span style=color:#f92672>.</span>attach_uprobe(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;c&#34;</span>,sym<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;malloc&#34;</span>,fn_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;trace_malloc&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>    (task, pid, cpu, flags, ts, msg) <span style=color:#f92672>=</span> bpf<span style=color:#f92672>.</span>trace_fields()
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;task=</span><span style=color:#e6db74>{</span>task<span style=color:#e6db74>}</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>msg=</span><span style=color:#e6db74>{</span>msg<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)</span></span></code></pre></div><p>This code is a little more complex, but still quite easy: first of all we use <em>bcc</em> to attach an &ldquo;user space probe&rdquo; instead of a kernel probe, and the function being observed will be libc&rsquo;s <strong>malloc</strong>.</p><p>In the tracing code itself, we simply report the parameter given to malloc function to the outside world, so with an infinite loop we print the tracing messages. Just to make it more explicit, we extract all the fields one by one and print only two of them.</p><p>It works like this: eBPF probe writes to a shared pipe named <code>/sys/kernel/debug/tracing/trace_pipe</code> , and python code reads from that pipe. The result is a fast scrolling stream of all the malloc invocations from all running programs, followed by the size requested.</p><p>| Field | Field | |</p><table><thead><tr><th>Number</th><th>Name</th><th>Meaning</th></tr></thead><tbody><tr><td>0</td><td>task</td><td>The name of the application running when the probe fired</td></tr><tr><td>1</td><td>pid</td><td>process id (PID) of the application</td></tr><tr><td>2</td><td>cpu</td><td>The CPU it was running on</td></tr><tr><td>3</td><td>flags</td><td>Various process context flags</td></tr><tr><td>4</td><td>ts</td><td>A timestamp</td></tr><tr><td>5</td><td>msg</td><td>The string that we passed to bpf_trace_printk()</td></tr></tbody></table><pre><code>task=b'Xorg'	msg=b'size=24'
task=b'Xorg'	msg=b'size=24'
task=b'gnome-terminal-'	msg=b'size=36'
task=b'gnome-terminal-'	msg=b'size=16'
task=b'Xorg'	msg=b'size=24'
task=b'gnome-terminal-'	msg=b'size=24'
task=b'gnome-terminal-'	msg=b'size=124'
task=b'Xorg'	msg=b'size=24'
task=b'gnome-terminal-'	msg=b'size=16'
task=b'gnome-terminal-'	msg=b'size=312'
task=b'Xorg'	msg=b'size=24'
task=b'gnome-terminal-'	msg=b'size=72'
</code></pre></div><footer class=content__footer></footer></section><section class=page__aside><div class=aside__about><div class=aside__about><img class=about__logo src=https://ilmanzo.github.io/images/rice.svg alt=Logo><h1 class=about__title>Andrea Manzini</h1><p class=about__description>A minimalist, pragmatic website and personal blog</p></div><ul class=aside__social-links><li><a href=https://github.com/ilmanzo rel=me aria-label=GitHub title=GitHub><i class="fab fa-github" aria-hidden=true></i></a>&nbsp;</li><li><a href=mailto:ilmanzo@gmail.com rel=me aria-label=Email title=Email><i class="fas fa-envelope" aria-hidden=true></i></a>&nbsp;</li><li><a href=https://www.linkedin.com/in/andreamanzini rel=me aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin" aria-hidden=true></i></a>&nbsp;</li><li><a href=https://twitter.com/ilmanzo rel=me aria-label=Twitter title=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a>&nbsp;</li><li><a href=https://ilmanzo.github.io/index.xml rel=me aria-label="RSS Feed" title="RSS Feed"><i class="fas fa-rss-square" aria-hidden=true></i></a>&nbsp;</li></ul></div><hr><div class=aside__content><p>some fun experiments with tracing and snooping linux kernel</p><p>By Andrea Manzini,
2021-05-19</p></div></section><footer class=page__footer><p class=copyright>Â© 2022 Andrea Manzini</p><p class=advertisement>Powered by <a href=https://gohugo.io/>hugo</a> and <a href=https://github.com/joeroe/risotto>risotto</a>.</p><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PN4FTRLNL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PN4FTRLNL",{anonymize_ip:!1})}</script></footer></div></body></html>