<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on ilManzo's blog</title><link>https://ilmanzo.github.io/tags/linux/</link><description>Recent content in linux on ilManzo's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2022 Andrea Manzini</copyright><lastBuildDate>Tue, 03 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ilmanzo.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>linux resource control with cgroups</title><link>https://ilmanzo.github.io/post/linux-resource-control-with-cgroups/</link><pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/linux-resource-control-with-cgroups/</guid><description>intro Resource isolation is an hot topic these days, and it&amp;rsquo;s a problem excellently solved by containerization. However, we can achieve isolation between internal tasks of an operating system by leveraging a technology exposed by the kernel: cgroups. This component is also used by Docker, and other Linux container technologies.
Cgroups are the Linux way of organizing groups of processes: roughly speaking a cgroup is to a process what a process is to a thread: one can have many threads belonging to the same process, and in the same way one can join many processes inside the same cgroup.</description></item><item><title>integration between Python and Rust - Part 2</title><link>https://ilmanzo.github.io/post/writing-python-modules-in-rust-2/</link><pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/writing-python-modules-in-rust-2/</guid><description>In this post we are going to write a new module for python: a very simple function exported from Rust that we can consume in the Python interpreter. We&amp;rsquo;ll leverage the PyO3 Rust bindings for the Python interpreter.
Let&amp;rsquo;s start with a new Cargo project:
$ cargo init --lib demo_rust_lib and insert the required settings in Cargo.toml:
[package] name = &amp;#34;rusty&amp;#34; version = &amp;#34;0.1.0&amp;#34; edition = &amp;#34;2021&amp;#34; [lib] name=&amp;#34;rusty&amp;#34; crate-type = [&amp;#34;cdylib&amp;#34;] [dependencies.</description></item><item><title>integration between Python and Rust - Part 1</title><link>https://ilmanzo.github.io/post/writing-python-modules-in-rust-1/</link><pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/writing-python-modules-in-rust-1/</guid><description>Let&amp;rsquo;s get our feet wet; in this first part I&amp;rsquo;ll write about a very simple way to interface Rust and Python. First of all let&amp;rsquo;s build a Rust dynamic library with some basic functions.
// this file is: src/lib.rs #[no_mangle] pub extern &amp;#34;C&amp;#34; fn hello() { println!(&amp;#34;Hello from the library!&amp;#34;); } #[no_mangle] pub extern &amp;#34;C&amp;#34; fn sum(a: i32, b: i32) -&amp;gt; i32 { a + b } your Cargo.</description></item><item><title>playing with eBPF interface - 2</title><link>https://ilmanzo.github.io/post/tracing-with-ebpf-02/</link><pubDate>Wed, 19 May 2021 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/tracing-with-ebpf-02/</guid><description>In the last post we introduced the BCC framework to interface Python code with eBPF facility. Now we are ready to make one step further!
#!/usr/bin/python3 import bcc bpf = bcc.BPF(text=&amp;#34;&amp;#34;&amp;#34; #include &amp;lt;uapi/linux/ptrace.h&amp;gt; int trace_malloc(struct pt_regs *ctx, size_t size) { bpf_trace_printk(&amp;#34;size=%d\\n&amp;#34;,size); return 0; };&amp;#34;&amp;#34;&amp;#34;) bpf.attach_uprobe(name=&amp;#34;c&amp;#34;,sym=&amp;#34;malloc&amp;#34;,fn_name=&amp;#34;trace_malloc&amp;#34;) while 1: (task, pid, cpu, flags, ts, msg) = bpf.trace_fields() print(f&amp;#34;task={task}\tmsg={msg}&amp;#34;) This code is a little more complex, but still quite easy: first of all we use bcc to attach an &amp;ldquo;user space probe&amp;rdquo; instead of a kernel probe, and the function being observed will be libc&amp;rsquo;s malloc.</description></item><item><title>playing with eBPF interface</title><link>https://ilmanzo.github.io/post/playing-with-ebpf-01/</link><pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/playing-with-ebpf-01/</guid><description>eBPF is a revolutionary technology that can run sandboxed programs in the Linux kernel without changing kernel source code or loading kernel modules. Basically any user can write code for a virtual machine that can interact with the kernel data structure and functions.
bcc is an high-level helper interface to eBPF (another is bpftrace). To use it, start by following installation guide , but if you have a recent Debian system, it&amp;rsquo;s just a matter of installing some packages:</description></item><item><title>Hijack C library functions in D</title><link>https://ilmanzo.github.io/post/hijack-c-library-function-in-d/</link><pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/hijack-c-library-function-in-d/</guid><description>I like playing with the D programming language and I wrote this little post to show how it&amp;rsquo;s easy to create a dynamic library (shared object, .so) that can be invoked in other programs; to have a little fun we will write a D replacement for the rand() C standard library function call. For your convenience, all the code is also on github
Let&amp;rsquo;s start with the demo implementation, a C program that calls 10 times the stdlib function rand() to get a random number.</description></item><item><title>a very simple NTP client in D</title><link>https://ilmanzo.github.io/post/a-simple-ntp-client-in-d/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/a-simple-ntp-client-in-d/</guid><description>I am quite a fan of the D programming language and I think it deserves more attention, even if since a few months it&amp;rsquo;s becoming more and more popular, as it gained top20 in the TIOBE Index for February 2020.
As an experiment in network programming, I took this simple NTP client written in C and translated to D ; in my opinion while it&amp;rsquo;s keeping the low-level nature, it&amp;rsquo;s shorter, clearer and more effective.</description></item><item><title>migrating a repository from mercurial to git</title><link>https://ilmanzo.github.io/post/migrating-a-repository-from-mercurial-to-git/</link><pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/migrating-a-repository-from-mercurial-to-git/</guid><description>Since bitbucket is sunsetting the support for mercurial repositories, I wrote a quick and dirty script to automate the migration from mercurial to GIT:
#!/bin/bash set -e set -u if [ &amp;#34;$#&amp;#34; -ne 3 ]; then echo &amp;#34;Illegal number of parameters&amp;#34; echo &amp;#34;usage: migrate.sh reponame hgrepourl gitrepourl&amp;#34; exit 1 fi REPONAME=$1 HGURL=$2 GITURL=$3 echo &amp;#34;Migrating $REPONAMEfrom $HGURLto $GITURL...&amp;#34; cd /tmp hg clone $HGURL cd $REPONAME hg bookmark -r default master hg bookmarks hg cd .</description></item><item><title>il linguaggio Lua: parte 14</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-14/</link><pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-14/</guid><description>segue dalla parte 13
Coroutine Come approccio alla programmazione concorrente, il linguaggio Lua non ha meccanismi interni per gestire nativamente i thread, ma si può appoggiare a ciò che offre il sistema operativo sottostante. Lua invece internamente offre il supporto alle coroutine: un programma Lua può avere diversi percorsi di esecuzione &amp;lsquo;parallela&amp;rsquo; ognuno col proprio stack e variabili locali ma che condividono risorse e variabili globali con le altre coroutine.</description></item><item><title>il linguaggio Lua: parte 13</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-13/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-13/</guid><description>segue dalla parte 12
Upvalue e Closure Per chi non ha familiarità con i concetti di programmazione funzionale questi termini possono sembrare un po’ oscuri; vediamo di chiarirli con un semplice esempio:
-- definisco una funzione che parte da un numero N e conta alla rovescia function CreaContatore(N) local v=N local function conta(x) if v&amp;gt;=x then v=v-x end return v end return conta end -- creo qualche istanza: contaDaDieci=CreaContatore(10) contaDaCento=CreaContatore(100) print(contaDaDieci(1)) 9 print(contaDaCento(1)) 99 print(contaDaCento(1)) 98 print(contaDaDieci(1)) 8 print(contaDaDieci(2)) 6 print(contaDaCento(10)) 88 osserviamo le variabili N,v che usate dalla funzione interna: non sono locali, ma nemmeno globali&amp;hellip; Sono upvalue, ovvero riferimenti che provengono da uno stackframe esterno.</description></item><item><title>il linguaggio Lua: parte 12</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-12/</link><pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-12/</guid><description>segue dalla parte 11
segnalazioni lunari Tra le rocks più interessanti citiamo quelle che permettono le operazioni di networking, come luasocket; salendo di livello, spicca il Kepler project, che comprende un intero stack per applicazioni web: Lapis micro framework, il framework MVC Sailor, e TurboLua, un tool per costuire velocissimi microservizi REST .
Concludiamo la panoramica sulle librerie accennando ai moduli per creare interfacce grafiche; al pari degli altri linguaggi di scripting, Lua offre binding per i maggiori toolkit grafici: curses, GTK, QT, fltk, wx si usano come negli altri linguaggi e sarebbe qui tedioso illustrarne le modalità.</description></item><item><title>il linguaggio Lua: parte 11</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-11/</link><pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-11/</guid><description>segue dalla parte 10
Rocce di Luna Poter organizzare il codice in più file è molto utile per modularizzare i programmi, creando package che verranno caricati tramite l&amp;rsquo;istruzione require “nomefile”. Vediamo un esempio:
-- geompkg.lua module(&amp;#34;geom&amp;#34;) local function quadrato(x) return x*x end local function rettangolo(b,h) return b*h end function area(param) if param.lato then return quadrato(param.lato) end local area=rettangolo(param.base,param.altezza) if param.triangolo or param.</description></item><item><title>il linguaggio Lua: parte 10</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-10/</link><pubDate>Fri, 03 Aug 2018 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-10/</guid><description>segue dalla parte 9
stringhe e regular expression in questa puntata apriremo una piccola digressione per analizzare le funzionalità del modulo string, in particolare l&amp;rsquo;uso delle regular expression.
Il modulo string ci mette a disposizione potenti funzioni di ricerca e sostituzione basate su espressioni regolari. Una completa implementazione delle regexp POSIX occuperebbe più dell&amp;rsquo;intero linguaggio, ma tutto sommato le funzionalità principali sono state mantenute, e gli autori di Lua sono riusciti a impacchettare un “motore” di pattern matching in meno di 500 righe di codice.</description></item><item><title>a honeypot ssh server in Go</title><link>https://ilmanzo.github.io/post/a-honeypot-ssh-server-in-go/</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/a-honeypot-ssh-server-in-go/</guid><description>honey-ssh-pot Curious about who and how attempts ssh login to your home server ? Me too&amp;hellip; So I wrote a very simple ssh honeypot, just to collect interesting info about the kind guys who knocks my door :)
warning: this is safe, but don&amp;rsquo;t run the service (well, ANY service) as root user. Even better if you can run it as a dedicate unprivileged user.
This program is only for didactic use and not intended for deployment in a production network environment.</description></item><item><title>il linguaggio Lua: parte 9</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-09/</link><pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-09/</guid><description>segue dalla parte 8
il modulo lunare Per mantenere la sua natura minimalista, Lua ha ben poche funzionalità incluse nel linguaggio e delega molti aspetti a librerie e moduli esterni. Ad esempio le operazioni matematiche sono accessibili nel package, o se preferite, namespace col prefisso math:
$ lua &amp;gt;print(math.sin(math.pi/2)) 1 sarebbe oltremodo noioso elencare tutte le funzioni presenti, basti dire che oltre alle funzioni trigonometriche abbiamo logaritmi, esponenziali, modulo, minimo, massimo, arrotondamenti e generazione di valori random.</description></item><item><title>il linguaggio Lua: ottava parte</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-08/</link><pubDate>Mon, 23 Apr 2018 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-08/</guid><description>segue dalla settima parte
Oggetti volanti e non Lua non è un linguaggio nativamente object-oriented. Se nei nostri script volessimo adottare uno stile OOP, ad esempio per modellare le operazioni su un conto corrente la cosa più naturale sarebbe usare una tabella:
Conto = { saldo = 200.0 } Questa sintassi potrebbe essere assimilata al &amp;lsquo;costruttore&amp;rsquo; dell&amp;rsquo;oggetto Conto. Possiamo anche definire dei metodi:
function Conto.preleva(cifra) Conto.saldo = Conto.saldo - cifra end e quindi potremmo comodamente chiamare, problemi economici a parte:</description></item><item><title>il linguaggio Lua: settima parte</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-07/</link><pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-07/</guid><description>segue dalla sesta parte
Iteratori e lua funzionale Cos&amp;rsquo;è un iteratore? Informaticamente parlando, è un costrutto che ci permette di scorrere strutture dati come liste, array, elenchi. In pratica, dato un elemento della struttura il compito dell&amp;rsquo;iteratore è farci avere il prossimo su cui operare. Non ci stupirà apprendere che in Lua gli iteratori sono funzioni. Vediamo un semplice esempio:
function reverse_iter(t) local i=#t+1 return function() i=i-1 if i&amp;gt;=0 then return t[i] end end end reverse_iter è una fabbrica (factory) di funzioni: ogni volta che la chiamiamo, ci crea una nuova closure, ossia l&amp;rsquo;iteratore specifico per l&amp;rsquo;array che gli passiamo.</description></item><item><title>il linguaggio Lua: sesta parte</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-06/</link><pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-06/</guid><description>segue dalla quinta parte
Quando il saggio indica la luna, lo sciocco guarda il dito Nello scorse puntate abbiamo appreso le basi di un linguaggio minimalista, il cui motto è “doing more with less”, che occupa meno byte della vostra foto su Facebook e che i benchmark dichiarano il più veloce tra i linguaggi di scripting. Nato da menti brasiliane, l&amp;rsquo;hanno chiamato Lua, che vuol dire Luna in portoghese. Lua viene usato come linguaggio di scripting in Angry Birds, World of Warcraft e decine di altri videogame e software: nello scorso post abbiamo visto come creare un semplice plugin per VLC.</description></item><item><title>linux: how to access DHCP options from client</title><link>https://ilmanzo.github.io/post/access-dhcp-options-from-client/</link><pubDate>Mon, 06 Nov 2017 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/access-dhcp-options-from-client/</guid><description>As you may know, you can configure any DHCP server to send many options to the clients; for example to setup dns domains, http proxy (WPAD) and so on.
If you need to access these options from a linux client, you must configure the client to ASK the server for the new options, by editing /etc/dhcp/dhclient.conf, and add an entry like:
option WPAD code 252 = string; also request WPAD; done that, when you&amp;rsquo;ll ask for a dhcp, the dhclient process will invoke your hook scripts with two new environment variables, old_WPAD and new_WPAD, with the values before and after the renewal.</description></item><item><title>il linguaggio Lua: quinta parte</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-05/</link><pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-05/</guid><description>segue dalla quarta parte
“Sonata al chiaro di luna” : un plugin per vlc Come dicevamo all&amp;rsquo;inizio, Lua è usato da numerose applicazioni come linguaggio di estensione; per scopi didattici ho scelto di scrivere un semplice plugin per un programma diffuso, il media player universale VLC. Con questo plugin risolveremo per sempre l&amp;rsquo;annoso problema di decidere cosa sarebbe meglio sgranocchiare durante la visione! L&amp;rsquo;integrazione con lo scripting Lua è documentata in una serie di file README.</description></item><item><title>il linguaggio Lua: parte 4</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-04/</link><pubDate>Tue, 11 Apr 2017 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-04/</guid><description>segue dalla terza parte
“Moonlight Bay” (ovvero: “chiedi chi erano i vectors”) L&amp;rsquo;unica struttura dati disponibile in Lua è rappresentata dagli array o meglio, dalle tabelle (o hash): array associativi formati da coppie chiave-valore, nelle quali sia la chiave sia il valore possono essere qualsiasi tipo di dato. Vediamo un paio di esempi, dapprima un normale vettore:
&amp;gt; i = 3 &amp;gt; a = {1,3,5,7,9} &amp;gt; print(i,a[3],a[4],a[i+3]) questa sequenza stampa i valori 3,5,7,nil; la prima cosa che appare diversa rispetto ad un altro linguaggio è che gli indici per gli array partono da 1 anziché da zero; la seconda è che un eventuale sforamento dell&amp;rsquo;array non causa errore ma semplicemente ritorna nil.</description></item><item><title>il linguaggio Lua: parte 3</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-03/</link><pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-03/</guid><description>segue dalla seconda parte
Che fai tu luna in ciel ? : le funzioni Fino a che scriviamo script di poche righe, possiamo inserire le istruzioni nel programma principale, ma aumentando la complessità diventa necessario organizzare il codice in pezzi indipendenti e riutilizzabili; come in tutti gli altri linguaggi, in Lua è possibile definire funzioni; vediamo un esempio piuttosto classico:
function fattoriale(n) local f=1 -- variabile locale alla funzione for i=2,n do f=f*i end return f Abbiamo definito la funzione fattoriale, che da ora in avanti possiamo richiamare nel nostro codice:</description></item><item><title>convert a binary file to ascii using hexdump</title><link>https://ilmanzo.github.io/post/hexdump-for-binary-file-manipulation/</link><pubDate>Thu, 20 Oct 2016 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/hexdump-for-binary-file-manipulation/</guid><description>I have a binary file with data stored as two-byte big-endian 16-bit words. We need to extract the values in the file and print them in decimal ASCII format, so to obtain numbers in the 0-655535 range.
let&amp;rsquo;s create the sample file:
$ echo -en &amp;#34;\x01\x02\x03\x04\x05\x06\x07\x08&amp;#34; &amp;gt; file.bin and show its content in binary form:
$ hexdump -C file.bin 00000000 01 02 03 04 05 06 07 08 |........| 00000008 to get the desired output we can use the powerful, but little documented format string option of hexdump:</description></item><item><title>il linguaggio Lua: parte 2</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-02/</link><pubDate>Tue, 24 May 2016 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-02/</guid><description>segue dalla prima parte
Moonwalking: Tipi di dato Nello scorsa puntata abbiamo utilizzato due degli otto tipi disponibili: i numeri e le stringhe. Per semplicita&amp;rsquo;, Lua non distingue tra interi e floating point: tutti i valori numerici sono conservati come double, cioe&amp;rsquo; in virgola mobile a doppia precisione. Nel caso la CPU non disponesse di unita&amp;rsquo; FPU, è possibile cambiare una riga nel sorgente (per l&amp;rsquo;esattezza, #define LUA_NUMBER in lua.h) e ricompilare; questo si fa tipicamente nei sistemi embedded con processori a basse prestazioni.</description></item><item><title>il linguaggio Lua: prima parte</title><link>https://ilmanzo.github.io/post/il-linguaggio-lua-01/</link><pubDate>Wed, 13 Apr 2016 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/il-linguaggio-lua-01/</guid><description>introduzione Ho sempre avuto un debole per il software leggero e snello: sara&amp;rsquo; un retaggio di quando la memoria si misurava in Kb e lo storage era basato su&amp;hellip; audiocassette! Lua e&amp;rsquo; un linguaggio che incarna questa filosofia: occupa circa un centinaio di kbyte (meno di molte pagine web), ha una stupefacente rapidita&amp;rsquo; di esecuzione, una sintassi chiara e, come bonus, gira su qualsiasi CPU per cui sia disponibile un compilatore C.</description></item><item><title>monit helper for quota monitoring in go</title><link>https://ilmanzo.github.io/post/golang-quota-monit-helper/</link><pubDate>Wed, 30 Mar 2016 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/golang-quota-monit-helper/</guid><description>I want to keep under control a system where each user has an amount of filesystem quota reserved; in particular I would like to get notified if and when a user exceeds some treshold. Since I already have Monit in place in the server, I took the chance to write a small Go utility in order to retrieve the quota percentage.
This is also an example on how to run external programs in Go and filter the output using regular expressions.</description></item><item><title>simple and easy linux job queue</title><link>https://ilmanzo.github.io/post/simple-easy-job-queue-linux/</link><pubDate>Mon, 21 Dec 2015 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/simple-easy-job-queue-linux/</guid><description>Recently I have been in a situation where I needed a simple &amp;lsquo;batch&amp;rsquo; job scheduler, where I could submit some long-running tasks to a server and have a &amp;lsquo;system&amp;rsquo; that serialize access the execution with some basic job control facilities (remove a job from the queue, stop the processing, and so on).
Linux printing subsystem is already designed to do this, and we can exploit the CUPS printing subsystem to run our &amp;ldquo;batch&amp;rdquo; jobs.</description></item><item><title>redirect output of an already running process</title><link>https://ilmanzo.github.io/post/redirect-output-of-running-process/</link><pubDate>Fri, 24 Apr 2015 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/redirect-output-of-running-process/</guid><description>Long story short: you have launched your script/program but forgot to redirect the output to a file for later inspection.
#!/usr/bin/python3 #sample endless running program that prints to stdout import time,datetime while True: print(datetime.datetime.now().time()) time.sleep(1) Using GNU Debugger you can re-attach to the process, then invoke the creation of a logfile and duplicate the file descriptor to make the system send the data to the new file, instead of the terminal:</description></item><item><title>Sincronizzare una directory tra due server linux</title><link>https://ilmanzo.github.io/post/simple-directory-sync/</link><pubDate>Fri, 20 Mar 2015 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/simple-directory-sync/</guid><description>Obiettivo vogliamo mantenere la stessa directory sincronizzata su due server linux.
Questo significa che ogni aggiunta/rimozione/modifica di file in questa directory verrà automaticamente riportato sull&amp;rsquo;altro (salvo conflitti). Diamo per assunto che i due server siano raggiungibili via rete, ma per qualsiasi motivo non sia possibile collegare dello spazio disco condiviso.
Implementazione Per raggiungere lo scopo, utilizzeremo il tool: csync2
su entrambi i server (che chiameremo nodo1 e nodo2), installiamo i pacchetti necessari:</description></item><item><title>monitor apache performance statistics</title><link>https://ilmanzo.github.io/post/logging-apache-performance-historical-statistics/</link><pubDate>Wed, 05 Nov 2014 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/logging-apache-performance-historical-statistics/</guid><description>the Apache module mod_status is very useful for inspecting your running webserver, but it gives you only realtime informations about workers, connections, and so on. I wanted a way to keep this data and then be able to do comparison, charts and more useful reports. The first step was configuring mod_status in order to be only accessible from localhost:
andrea@myserver:~$ cat /etc/apache2/mods-enabled/status.conf &amp;lt;IfModule mod_status.c&amp;gt; # # Allow server status reports generated by mod_status, # with the URL of http://servername/server-status # Uncomment and change the &amp;#34;192.</description></item><item><title>Linux: get simple I/O statistics per process</title><link>https://ilmanzo.github.io/post/simple-io-statistics-per-process/</link><pubDate>Fri, 22 Aug 2014 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/simple-io-statistics-per-process/</guid><description>I had a trouble with a long process running and wish to know how much I/O this process is doing, so I wrote this quick and dirty python 2.x script:
import time,sys,datetime def read_stat(pid): f=open(&amp;#34;/proc/%s/io&amp;#34; % pid ,&amp;#34;r&amp;#34;) for line in f: if line.startswith(&amp;#39;rchar&amp;#39;): rchar=line.split(&amp;#39;:&amp;#39;)[1] continue if line.startswith(&amp;#39;wchar&amp;#39;): wchar=line.split(&amp;#39;:&amp;#39;)[1] continue f.close() return int(rchar),int(wchar) pid=sys.argv[1] r0,w0 = read_stat(pid) while 1: time.</description></item><item><title>how to setup disk redundancy with BTRFS filesystem</title><link>https://ilmanzo.github.io/post/btrfs-mirroring/</link><pubDate>Wed, 09 Jul 2014 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/btrfs-mirroring/</guid><description>Starting with a plain old one-disk configuration&amp;hellip;
# df -h Filesystem Size Used Avail Use% Mounted on /dev/sda2 5.8G 590M 5.0G 11% /data thanks to the power of btrfs, let&amp;rsquo;s add a second hard disk, with mirrored data AND without unmounting/reformatting! :) also note the different size&amp;hellip;.
# fdisk -l Disk /dev/sda: 6 GiB, 6442450944 bytes, 12582912 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0xea97ecdc Device Boot Start End Blocks Id System /dev/sda1 2048 526335 262144 82 Linux swap / Solaris /dev/sda2 * 526336 12582911 6028288 83 Linux Disk /dev/sdb: 4 GiB, 4294967296 bytes, 8388608 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes &amp;hellip; state of the filesystem before the change&amp;hellip;</description></item><item><title>Compress and encrypt your backups</title><link>https://ilmanzo.github.io/post/compress-and-encrypt-your-remote-backups/</link><pubDate>Wed, 11 Jun 2014 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/compress-and-encrypt-your-remote-backups/</guid><description>It&amp;rsquo;s always recommended to backup your data for safety, but for safety AND security let&amp;rsquo;s encrypt your backups!
to compress and encrypt with &amp;lsquo;mypassword&amp;rsquo;: tar -Jcf - directory | openssl aes-256-cbc -salt -k mypassword -out backup.tar.xz.aes
to decrypt and decompress: openssl aes-256-cbc -d -salt -k mypassword -in backup.tar.xz.aes | tar -xJ -f -
Another trick with the tar command is useful for remote backups: tar -zcvfp - /wwwdata | ssh root@remote.</description></item><item><title>how to display the IP address of a virtual machine before logon</title><link>https://ilmanzo.github.io/post/know-your-vm-address-before-logon/</link><pubDate>Mon, 05 May 2014 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/know-your-vm-address-before-logon/</guid><description>For testing or development purposes, I do a wide use of small linux virtual machines.
After spawning a new guest (Virtualbox, VMWare or any other), often you want to log on over ssh but you don&amp;rsquo;t yet know its ip address. You need to login as &amp;lsquo;root&amp;rsquo; in the console just to issue a quick &amp;lsquo;ifconfig&amp;rsquo;, and after writing down the address, you logout and connect with your comfortable terminal. In order to save some time and keystrokes, I put this in my rc.</description></item><item><title>dovecot: cleaning old Spam and Trash messages after some days</title><link>https://ilmanzo.github.io/post/postfix-dovecot-cleanup-virtual-folders/</link><pubDate>Wed, 05 Mar 2014 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/postfix-dovecot-cleanup-virtual-folders/</guid><description>This script is useful to delete old messages in &amp;ldquo;Junk&amp;rdquo; mail folders (Spam, Trash) automatically after some days.
adapted from these notes to work on debian/postfixadmin/dovecot
#!/bin/bash # # itera sulle mailbox cancellando messaggi vecchi # per default, nel cestino 30gg e Spam 15 gg # # MySQL details HOST=&amp;#34;127.0.0.1&amp;#34;; USER=&amp;#34;put_here_your_mysql_user&amp;#34;; PWD=&amp;#34;put_here_your_mysql_password&amp;#34;; MYSQL=&amp;#34;/usr/bin/mysql&amp;#34;; # dovecot details DOVEADM=&amp;#34;/usr/bin/doveadm&amp;#34;; TEMPFILE=$(/bin/mktemp) # Output sql to a file that we want to run echo &amp;#34;use postfixadmin; select username from mailbox&amp;#34; &amp;gt; $TEMPFILE # Run the query and get the results (adjust the path to mysql) results=$($MYSQL -h $HOST -u $USER -p$PWD -N &amp;lt; $TEMPFILE); # Loop through each row for row in $results do echo &amp;#34;Purging $rowTrash and Junk mailbox.</description></item><item><title>number of physical sockets and cpu cores</title><link>https://ilmanzo.github.io/post/sockets-and-cores/</link><pubDate>Sat, 14 Sep 2013 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/sockets-and-cores/</guid><description>a small script to check out the number of processors in your linux machine
#!/bin/bash S=$(grep "physical id" /proc/cpuinfo | sort -u | wc -l) C=$(grep "cpu cores" /proc/cpuinfo |sort -u |cut -d":" -f2) grep -i "model name" /proc/cpuinfo echo your system has $S sockets with $C CPU cores each mandatory sample output:
model name : Intel(R) Xeon(R) CPU L5640 @ 2.27GHz your system has 2 sockets with 6 CPU cores each</description></item><item><title>run-parts e problemi di crontab</title><link>https://ilmanzo.github.io/post/run-parts-problemi-crontab/</link><pubDate>Thu, 06 Dec 2012 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/run-parts-problemi-crontab/</guid><description>Mi e&amp;rsquo; capitato di inserire degli script nelle varie directory /etc/cron.daily, /etc/cron.weekly ma di scoprire che questi script non vengono eseguiti. Il motivo e&amp;rsquo; che il run-parts usato nelle Debian e derivate ignora i file che contengono un &amp;ldquo;.&amp;rdquo; (e quindi tutti quelli con l&amp;rsquo;estensione)
Questo comportamento e&amp;rsquo; documentato anche nella man page, e previene alcuni inconvenienti come l&amp;rsquo;esecuzione dei .bak ma lo scrivo anche qui per ricordarmelo &amp;hellip; E forse potra&amp;rsquo; essere utile a qualcun altro :)</description></item><item><title>generare comandi di creazione utenze a partire da un passwd</title><link>https://ilmanzo.github.io/post/generare-comandi-di-creazione-utenze-a-partire-da-un-passwd/</link><pubDate>Fri, 23 Nov 2012 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/generare-comandi-di-creazione-utenze-a-partire-da-un-passwd/</guid><description>A volte e&amp;rsquo; necessario replicare le utenze con gli stessi parametri su piu&amp;rsquo; server linux diversi.
Perche&amp;rsquo; farlo a mano ? Se sono tanti e&amp;rsquo; un lavoro noioso e potremmo anche commettere degli errori.
Ecco un semplice one-liner che fa il parsing di un file /etc/passwd e genera i corrispondenti comandi useradd
awk -F: '{printf &amp;quot;useradd -m -u%s -g%s -d%s -s%s %s\n&amp;quot; , $3,$4,$6,$7,$1}' /etc/passwd Ovviamente l&amp;rsquo;output puo&amp;rsquo; essere comodamente filtrato con grep, usato via copy&amp;amp;paste, inserito in uno script, eccetera&amp;hellip;</description></item><item><title>gestire i led delle schede PC Engines ALIX in Ruby</title><link>https://ilmanzo.github.io/post/gestire-i-led-delle-schede-pc-engines-alix/</link><pubDate>Fri, 09 Nov 2012 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/gestire-i-led-delle-schede-pc-engines-alix/</guid><description>Natale si avvicina: mentre smanettavo su queste ottime PC Engines ALIX su cui ho installato una Debian modificata, ho scritto una comoda interfaccia per accendere/spegnere e far lampeggiare i led alla velocita&amp;rsquo; desiderata&amp;hellip;
class Led #numero da 1 a 3 def initialize(ledno) ledno++ # passo 0 ma comando 1 ledno=1 if ledno&amp;lt;1 ledno=3 if ledno&amp;gt;3 @ledsyspath=&amp;#34;/sys/devices/platform/leds_alix2/leds/alix:#{ledno}/&amp;#34; end def blink(millisec) File.open(@ledsyspath+&amp;#39;trigger&amp;#39;,&amp;#39;w&amp;#39;) { |f| f.</description></item><item><title>background tasks in Ruby e linux</title><link>https://ilmanzo.github.io/post/background-tasks-in-ruby-e-linux/</link><pubDate>Mon, 05 Nov 2012 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/background-tasks-in-ruby-e-linux/</guid><description>A volte negli script Ruby ho bisogno di controllare l&amp;rsquo;esecuzione di un comando eseguito in modalita&amp;rsquo; asincrona, ho creato pertanto una classe apposita:
class BackgroundJob def initialize(cmd) @pid = fork do # this code is run in the child process # you can do anything here, like changing current directory or reopening STDOUT exec cmd end end def stop! # kill it (other signals than TERM may be used, depending on the program you want # to kill.</description></item><item><title>Linux Day 2012</title><link>https://ilmanzo.github.io/post/linux-day-2012/</link><pubDate>Sat, 03 Nov 2012 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/linux-day-2012/</guid><description>Anche quest&amp;rsquo;anno ho avuto il piacere di partecipare al Linux Day, organizzato per Verona presso la sede del LUG Verona in via dei Gelsi a Montorio; Ho tenuto una breve presentazione su un argomento che mi sta a cuore: partecipare attivamente alla comunita&amp;rsquo; del software libero, perche&amp;rsquo; anche se ormai Linux e Il free software hanno una discreta diffusione, la maggior parte degli utenti si limita all&amp;rsquo;utilizzo passivo e anzi spesso si lamenta per la scarsa qualita&amp;rsquo; del software open.</description></item></channel></rss>