<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on ilManzo's blog</title><link>https://ilmanzo.github.io/tags/python/</link><description>Recent content in python on ilManzo's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Â© 2022 Andrea Manzini</copyright><lastBuildDate>Fri, 07 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ilmanzo.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>integration between Python and Rust - Part 2</title><link>https://ilmanzo.github.io/post/writing-python-modules-in-rust-2/</link><pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/writing-python-modules-in-rust-2/</guid><description>In this post we are going to write a new module for python: a very simple function exported from Rust that we can consume in the Python interpreter. We&amp;rsquo;ll leverage the PyO3 Rust bindings for the Python interpreter.
Let&amp;rsquo;s start with a new Cargo project:
$ cargo init --lib demo_rust_lib and insert the required settings in Cargo.toml:
[package] name = &amp;#34;rusty&amp;#34; version = &amp;#34;0.1.0&amp;#34; edition = &amp;#34;2021&amp;#34; [lib] name=&amp;#34;rusty&amp;#34; crate-type = [&amp;#34;cdylib&amp;#34;] [dependencies.</description></item><item><title>integration between Python and Rust - Part 1</title><link>https://ilmanzo.github.io/post/writing-python-modules-in-rust-1/</link><pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/writing-python-modules-in-rust-1/</guid><description>Let&amp;rsquo;s get our feet wet; in this first part I&amp;rsquo;ll write about a very simple way to interface Rust and Python. First of all let&amp;rsquo;s build a Rust dynamic library with some basic functions.
// this file is: src/lib.rs #[no_mangle] pub extern &amp;#34;C&amp;#34; fn hello() { println!(&amp;#34;Hello from the library!&amp;#34;); } #[no_mangle] pub extern &amp;#34;C&amp;#34; fn sum(a: i32, b: i32) -&amp;gt; i32 { a + b } your Cargo.toml should look like this:</description></item><item><title>playing with eBPF interface - 2</title><link>https://ilmanzo.github.io/post/tracing-with-ebpf-02/</link><pubDate>Wed, 19 May 2021 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/tracing-with-ebpf-02/</guid><description>In the last post we introduced the BCC framework to interface Python code with eBPF facility. Now we are ready to make one step further!
#!/usr/bin/python3 import bcc bpf = bcc.BPF(text=&amp;#34;&amp;#34;&amp;#34; #include &amp;lt;uapi/linux/ptrace.h&amp;gt; int trace_malloc(struct pt_regs *ctx, size_t size) { bpf_trace_printk(&amp;#34;size=%d\\n&amp;#34;,size); return 0; };&amp;#34;&amp;#34;&amp;#34;) bpf.attach_uprobe(name=&amp;#34;c&amp;#34;,sym=&amp;#34;malloc&amp;#34;,fn_name=&amp;#34;trace_malloc&amp;#34;) while 1: (task, pid, cpu, flags, ts, msg) = bpf.trace_fields() print(f&amp;#34;task={task}\tmsg={msg}&amp;#34;) This code is a little more complex, but still quite easy: first of all we use bcc to attach an &amp;ldquo;user space probe&amp;rdquo; instead of a kernel probe, and the function being observed will be libc&amp;rsquo;s malloc.</description></item><item><title>playing with eBPF interface -1</title><link>https://ilmanzo.github.io/post/playing-with-ebpf-01/</link><pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/playing-with-ebpf-01/</guid><description>eBPF is a revolutionary technology that can run sandboxed programs in the Linux kernel without changing kernel source code or loading kernel modules. Basically any user can write code for a virtual machine that can interact with the kernel data structure and functions.
bcc is an high-level helper interface to eBPF (another is bpftrace). To use it, start by following installation guide , but if you have a recent Debian system, it&amp;rsquo;s just a matter of installing some packages:</description></item><item><title>a 'pythonic' fileinput module for the D programming language</title><link>https://ilmanzo.github.io/post/fileinput-for-d-programming-language/</link><pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/fileinput-for-d-programming-language/</guid><description>When I write small command line utilities in Python, I often take advantage of the fileinput module that makes working with text files very convenient: the library permits to write quickly and easily a loop over standard input or a list of files, something like perl -a or awk line processing.
Then the size of input data grew, and also for a language comparison, I wanted to port my utility in the D programming language, but I cannot find an equivalent module, so I decided to write one myself.</description></item><item><title>Writing Python modules in Nim</title><link>https://ilmanzo.github.io/post/writing-python-modules-in-nim/</link><pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/writing-python-modules-in-nim/</guid><description>Nim is a statically typed compiled systems programming language. It combines successful concepts from mature languages like Python, Ada and Modula. It&amp;rsquo;s Efficient, expressive, elegant and definitely worth to check.
While I was playing with it, I stumbled upon an interesting module that allows almost seamless interoperability betweeen Nim and Python; so I&amp;rsquo;m building a small proof of concept on this github project.
first of all the Nim code: # file: demo.</description></item><item><title>wrapping c plus plus classes in Python</title><link>https://ilmanzo.github.io/post/wrapping-c-plus-plus-classes-in-python/</link><pubDate>Mon, 08 Aug 2016 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/wrapping-c-plus-plus-classes-in-python/</guid><description>This is a quick and dirty way to interface C++ code with Python, translating one or more C++ classes in Python objects.
First, we need some c++ sample code:
//myclass.h #ifndef MYCLASS_H #define MYCLASS_H #include &amp;lt;string&amp;gt; using namespace std; namespace pets { class Dog { public: Dog(string name, int age); virtual ~Dog(); string talk(); protected: string m_name; int m_age; }; } //myclass.cpp #include &amp;#34;myclass.h&amp;#34; #include &amp;lt;string&amp;gt; namespace pets { Dog::Dog(std::string name, int age): m_name(name),m_age(age) { } Dog::~Dog() { } std::string Dog::talk() { return &amp;#34;BARK!</description></item><item><title>serata introduttiva al FabLab sulla programmazione Python</title><link>https://ilmanzo.github.io/post/serata-fablab/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/serata-fablab/</guid><description>Pubblico qui le slide che ho usato durante la serata dedicata alla programmazione Python, svoltasi presso il FabLab Verona
http://ilmanzo.github.io/files/slide_serata_python_fablab_2015.html</description></item><item><title>Linux: get simple I/O statistics per process</title><link>https://ilmanzo.github.io/post/simple-io-statistics-per-process/</link><pubDate>Fri, 22 Aug 2014 00:00:00 +0000</pubDate><guid>https://ilmanzo.github.io/post/simple-io-statistics-per-process/</guid><description>I had a trouble with a long process running and wish to know how much I/O this process is doing, so I wrote this quick and dirty python 2.x script:
import time,sys,datetime def read_stat(pid): f=open(&amp;#34;/proc/%s/io&amp;#34; % pid ,&amp;#34;r&amp;#34;) for line in f: if line.startswith(&amp;#39;rchar&amp;#39;): rchar=line.split(&amp;#39;:&amp;#39;)[1] continue if line.startswith(&amp;#39;wchar&amp;#39;): wchar=line.split(&amp;#39;:&amp;#39;)[1] continue f.close() return int(rchar),int(wchar) pid=sys.argv[1] r0,w0 = read_stat(pid) while 1: time.sleep(1) r1,w1 = read_stat(pid) print &amp;#34;%s\t\tr=%s\t\tw=%s&amp;#34; % (datetime.datetime.now().time(),r1-r0,w1-w0) r0,w0=r1,w1 You must give the process PID number as input to the script.</description></item></channel></rss>